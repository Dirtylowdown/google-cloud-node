// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/api/quota.proto (package google.api, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Quota configuration helps to achieve fairness and budgeting in service
 * usage.
 *
 * The metric based quota configuration works this way:
 * - The service configuration defines a set of metrics.
 * - For API calls, the quota.metric_rules maps methods to metrics with
 *   corresponding costs.
 * - The quota.limits defines limits on the metrics, which will be used for
 *   quota checks at runtime.
 *
 * An example quota configuration in yaml format:
 *
 *    quota:
 *      limits:
 *
 *      - name: apiWriteQpsPerProject
 *        metric: library.googleapis.com/write_calls
 *        unit: "1/min/{project}"  # rate limit for consumer projects
 *        values:
 *          STANDARD: 10000
 *
 *
 *      (The metric rules bind all methods to the read_calls metric,
 *       except for the UpdateBook and DeleteBook methods. These two methods
 *       are mapped to the write_calls metric, with the UpdateBook method
 *       consuming at twice rate as the DeleteBook method.)
 *      metric_rules:
 *      - selector: "*"
 *        metric_costs:
 *          library.googleapis.com/read_calls: 1
 *      - selector: google.example.library.v1.LibraryService.UpdateBook
 *        metric_costs:
 *          library.googleapis.com/write_calls: 2
 *      - selector: google.example.library.v1.LibraryService.DeleteBook
 *        metric_costs:
 *          library.googleapis.com/write_calls: 1
 *
 *  Corresponding Metric definition:
 *
 *      metrics:
 *      - name: library.googleapis.com/read_calls
 *        display_name: Read requests
 *        metric_kind: DELTA
 *        value_type: INT64
 *
 *      - name: library.googleapis.com/write_calls
 *        display_name: Write requests
 *        metric_kind: DELTA
 *        value_type: INT64
 *
 *
 *
 * @generated from message google.api.Quota
 */
export class Quota extends Message<Quota> {
  /**
   * List of QuotaLimit definitions for the service.
   *
   * @generated from field: repeated google.api.QuotaLimit limits = 3;
   */
  limits: QuotaLimit[] = [];

  /**
   * List of MetricRule definitions, each one mapping a selected method to one
   * or more metrics.
   *
   * @generated from field: repeated google.api.MetricRule metric_rules = 4;
   */
  metricRules: MetricRule[] = [];

  constructor(data?: PartialMessage<Quota>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Quota";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "limits", kind: "message", T: QuotaLimit, repeated: true },
    { no: 4, name: "metric_rules", kind: "message", T: MetricRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quota {
    return new Quota().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quota {
    return new Quota().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quota {
    return new Quota().fromJsonString(jsonString, options);
  }

  static equals(a: Quota | PlainMessage<Quota> | undefined, b: Quota | PlainMessage<Quota> | undefined): boolean {
    return proto3.util.equals(Quota, a, b);
  }
}

/**
 * Bind API methods to metrics. Binding a method to a metric causes that
 * metric's configured quota behaviors to apply to the method call.
 *
 * @generated from message google.api.MetricRule
 */
export class MetricRule extends Message<MetricRule> {
  /**
   * Selects the methods to which this rule applies.
   *
   * Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
   *
   * @generated from field: string selector = 1;
   */
  selector = "";

  /**
   * Metrics to update when the selected methods are called, and the associated
   * cost applied to each metric.
   *
   * The key of the map is the metric name, and the values are the amount
   * increased for the metric against which the quota limits are defined.
   * The value must not be negative.
   *
   * @generated from field: map<string, int64> metric_costs = 2;
   */
  metricCosts: { [key: string]: bigint } = {};

  constructor(data?: PartialMessage<MetricRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.MetricRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "selector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metric_costs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 3 /* ScalarType.INT64 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricRule {
    return new MetricRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricRule {
    return new MetricRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricRule {
    return new MetricRule().fromJsonString(jsonString, options);
  }

  static equals(a: MetricRule | PlainMessage<MetricRule> | undefined, b: MetricRule | PlainMessage<MetricRule> | undefined): boolean {
    return proto3.util.equals(MetricRule, a, b);
  }
}

/**
 * `QuotaLimit` defines a specific limit that applies over a specified duration
 * for a limit type. There can be at most one limit for a duration and limit
 * type combination defined within a `QuotaGroup`.
 *
 * @generated from message google.api.QuotaLimit
 */
export class QuotaLimit extends Message<QuotaLimit> {
  /**
   * Name of the quota limit.
   *
   * The name must be provided, and it must be unique within the service. The
   * name can only include alphanumeric characters as well as '-'.
   *
   * The maximum length of the limit name is 64 characters.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  /**
   * Optional. User-visible, extended description for this quota limit.
   * Should be used only when more context is needed to understand this limit
   * than provided by the limit's display name (see: `display_name`).
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Default number of tokens that can be consumed during the specified
   * duration. This is the number of tokens assigned when a client
   * application developer activates the service for his/her project.
   *
   * Specifying a value of 0 will block all requests. This can be used if you
   * are provisioning quota to selected consumers and blocking others.
   * Similarly, a value of -1 will indicate an unlimited quota. No other
   * negative values are allowed.
   *
   * Used by group-based quotas only.
   *
   * @generated from field: int64 default_limit = 3;
   */
  defaultLimit = protoInt64.zero;

  /**
   * Maximum number of tokens that can be consumed during the specified
   * duration. Client application developers can override the default limit up
   * to this maximum. If specified, this value cannot be set to a value less
   * than the default limit. If not specified, it is set to the default limit.
   *
   * To allow clients to apply overrides with no upper bound, set this to -1,
   * indicating unlimited maximum quota.
   *
   * Used by group-based quotas only.
   *
   * @generated from field: int64 max_limit = 4;
   */
  maxLimit = protoInt64.zero;

  /**
   * Free tier value displayed in the Developers Console for this limit.
   * The free tier is the number of tokens that will be subtracted from the
   * billed amount when billing is enabled.
   * This field can only be set on a limit with duration "1d", in a billable
   * group; it is invalid on any other limit. If this field is not set, it
   * defaults to 0, indicating that there is no free tier for this service.
   *
   * Used by group-based quotas only.
   *
   * @generated from field: int64 free_tier = 7;
   */
  freeTier = protoInt64.zero;

  /**
   * Duration of this limit in textual notation. Must be "100s" or "1d".
   *
   * Used by group-based quotas only.
   *
   * @generated from field: string duration = 5;
   */
  duration = "";

  /**
   * The name of the metric this quota limit applies to. The quota limits with
   * the same metric will be checked together during runtime. The metric must be
   * defined within the service config.
   *
   * @generated from field: string metric = 8;
   */
  metric = "";

  /**
   * Specify the unit of the quota limit. It uses the same syntax as
   * [Metric.unit][]. The supported unit kinds are determined by the quota
   * backend system.
   *
   * Here are some examples:
   * * "1/min/{project}" for quota per minute per project.
   *
   * Note: the order of unit components is insignificant.
   * The "1" at the beginning is required to follow the metric unit syntax.
   *
   * @generated from field: string unit = 9;
   */
  unit = "";

  /**
   * Tiered limit values. You must specify this as a key:value pair, with an
   * integer value that is the maximum number of requests allowed for the
   * specified unit. Currently only STANDARD is supported.
   *
   * @generated from field: map<string, int64> values = 10;
   */
  values: { [key: string]: bigint } = {};

  /**
   * User-visible display name for this limit.
   * Optional. If not set, the UI will provide a default display name based on
   * the quota configuration. This field can be used to override the default
   * display name generated from the configuration.
   *
   * @generated from field: string display_name = 12;
   */
  displayName = "";

  constructor(data?: PartialMessage<QuotaLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.QuotaLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "default_limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "max_limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "free_tier", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "duration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "metric", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "values", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 3 /* ScalarType.INT64 */} },
    { no: 12, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuotaLimit {
    return new QuotaLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuotaLimit {
    return new QuotaLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuotaLimit {
    return new QuotaLimit().fromJsonString(jsonString, options);
  }

  static equals(a: QuotaLimit | PlainMessage<QuotaLimit> | undefined, b: QuotaLimit | PlainMessage<QuotaLimit> | undefined): boolean {
    return proto3.util.equals(QuotaLimit, a, b);
  }
}

