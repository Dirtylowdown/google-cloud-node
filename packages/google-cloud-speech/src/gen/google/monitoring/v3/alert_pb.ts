// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/alert.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { BoolValue, Duration, Message, proto3 } from "@bufbuild/protobuf";
import { Status } from "../../rpc/status_pb.js";
import { MutationRecord } from "./mutation_record_pb.js";
import { Aggregation, ComparisonType } from "./common_pb.js";

/**
 * A description of the conditions under which some aspect of your system is
 * considered to be "unhealthy" and the ways to notify people or services about
 * this state. For an overview of alert policies, see
 * [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
 *
 * @generated from message google.monitoring.v3.AlertPolicy
 */
export class AlertPolicy extends Message<AlertPolicy> {
  /**
   * Required if the policy exists. The resource name for this policy. The
   * format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
   *
   * `[ALERT_POLICY_ID]` is assigned by Cloud Monitoring when the policy
   * is created. When calling the
   * [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
   * method, do not include the `name` field in the alerting policy passed as
   * part of the request.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A short name or phrase used to identify the policy in dashboards,
   * notifications, and incidents. To avoid confusion, don't use the same
   * display name for multiple policies in the same project. The name is
   * limited to 512 Unicode characters.
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * Documentation that is included with notifications and incidents related to
   * this policy. Best practice is for the documentation to include information
   * to help responders understand, mitigate, escalate, and correct the
   * underlying problems detected by the alerting policy. Notification channels
   * that have limited capacity might not show this documentation.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Documentation documentation = 13;
   */
  documentation?: AlertPolicy_Documentation;

  /**
   * User-supplied key/value data to be used for organizing and
   * identifying the `AlertPolicy` objects.
   *
   * The field can contain up to 64 entries. Each key and value is limited to
   * 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
   * values can contain only lowercase letters, numerals, underscores, and
   * dashes. Keys must begin with a letter.
   *
   * @generated from field: map<string, string> user_labels = 16;
   */
  userLabels: { [key: string]: string } = {};

  /**
   * A list of conditions for the policy. The conditions are combined by AND or
   * OR according to the `combiner` field. If the combined conditions evaluate
   * to true, then an incident is created. A policy can have from one to six
   * conditions.
   * If `condition_time_series_query_language` is present, it must be the only
   * `condition`.
   *
   * @generated from field: repeated google.monitoring.v3.AlertPolicy.Condition conditions = 12;
   */
  conditions: AlertPolicy_Condition[] = [];

  /**
   * How to combine the results of multiple conditions to determine if an
   * incident should be opened.
   * If `condition_time_series_query_language` is present, this must be
   * `COMBINE_UNSPECIFIED`.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.ConditionCombinerType combiner = 6;
   */
  combiner = AlertPolicy_ConditionCombinerType.COMBINE_UNSPECIFIED;

  /**
   * Whether or not the policy is enabled. On write, the default interpretation
   * if unset is that the policy is enabled. On read, clients should not make
   * any assumption about the state if it has not been populated. The
   * field should always be populated on List and Get operations, unless
   * a field projection has been specified that strips it out.
   *
   * @generated from field: google.protobuf.BoolValue enabled = 17;
   */
  enabled?: boolean;

  /**
   * Read-only description of how the alert policy is invalid. OK if the alert
   * policy is valid. If not OK, the alert policy will not generate incidents.
   *
   * @generated from field: google.rpc.Status validity = 18;
   */
  validity?: Status;

  /**
   * Identifies the notification channels to which notifications should be sent
   * when incidents are opened or closed or when new violations occur on
   * an already opened incident. Each element of this array corresponds to
   * the `name` field in each of the
   * [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
   * objects that are returned from the [`ListNotificationChannels`]
   * [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
   * method. The format of the entries in this field is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   *
   * @generated from field: repeated string notification_channels = 14;
   */
  notificationChannels: string[] = [];

  /**
   * A read-only record of the creation of the alerting policy. If provided
   * in a call to create or update, this field will be ignored.
   *
   * @generated from field: google.monitoring.v3.MutationRecord creation_record = 10;
   */
  creationRecord?: MutationRecord;

  /**
   * A read-only record of the most recent change to the alerting policy. If
   * provided in a call to create or update, this field will be ignored.
   *
   * @generated from field: google.monitoring.v3.MutationRecord mutation_record = 11;
   */
  mutationRecord?: MutationRecord;

  /**
   * Control over how this alert policy's notification channels are notified.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.AlertStrategy alert_strategy = 21;
   */
  alertStrategy?: AlertPolicy_AlertStrategy;

  constructor(data?: PartialMessage<AlertPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "documentation", kind: "message", T: AlertPolicy_Documentation },
    { no: 16, name: "user_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 12, name: "conditions", kind: "message", T: AlertPolicy_Condition, repeated: true },
    { no: 6, name: "combiner", kind: "enum", T: proto3.getEnumType(AlertPolicy_ConditionCombinerType) },
    { no: 17, name: "enabled", kind: "message", T: BoolValue },
    { no: 18, name: "validity", kind: "message", T: Status },
    { no: 14, name: "notification_channels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "creation_record", kind: "message", T: MutationRecord },
    { no: 11, name: "mutation_record", kind: "message", T: MutationRecord },
    { no: 21, name: "alert_strategy", kind: "message", T: AlertPolicy_AlertStrategy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy {
    return new AlertPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy {
    return new AlertPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy {
    return new AlertPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy | PlainMessage<AlertPolicy> | undefined, b: AlertPolicy | PlainMessage<AlertPolicy> | undefined): boolean {
    return proto3.util.equals(AlertPolicy, a, b);
  }
}

/**
 * Operators for combining conditions.
 *
 * @generated from enum google.monitoring.v3.AlertPolicy.ConditionCombinerType
 */
export enum AlertPolicy_ConditionCombinerType {
  /**
   * An unspecified combiner.
   *
   * @generated from enum value: COMBINE_UNSPECIFIED = 0;
   */
  COMBINE_UNSPECIFIED = 0,

  /**
   * Combine conditions using the logical `AND` operator. An
   * incident is created only if all the conditions are met
   * simultaneously. This combiner is satisfied if all conditions are
   * met, even if they are met on completely different resources.
   *
   * @generated from enum value: AND = 1;
   */
  AND = 1,

  /**
   * Combine conditions using the logical `OR` operator. An incident
   * is created if any of the listed conditions is met.
   *
   * @generated from enum value: OR = 2;
   */
  OR = 2,

  /**
   * Combine conditions using logical `AND` operator, but unlike the regular
   * `AND` option, an incident is created only if all conditions are met
   * simultaneously on at least one resource.
   *
   * @generated from enum value: AND_WITH_MATCHING_RESOURCE = 3;
   */
  AND_WITH_MATCHING_RESOURCE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AlertPolicy_ConditionCombinerType)
proto3.util.setEnumType(AlertPolicy_ConditionCombinerType, "google.monitoring.v3.AlertPolicy.ConditionCombinerType", [
  { no: 0, name: "COMBINE_UNSPECIFIED" },
  { no: 1, name: "AND" },
  { no: 2, name: "OR" },
  { no: 3, name: "AND_WITH_MATCHING_RESOURCE" },
]);

/**
 * A content string and a MIME type that describes the content string's
 * format.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Documentation
 */
export class AlertPolicy_Documentation extends Message<AlertPolicy_Documentation> {
  /**
   * The text of the documentation, interpreted according to `mime_type`.
   * The content may not exceed 8,192 Unicode characters and may not exceed
   * more than 10,240 bytes when encoded in UTF-8 format, whichever is
   * smaller. This text can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   *
   * @generated from field: string content = 1;
   */
  content = "";

  /**
   * The format of the `content` field. Presently, only the value
   * `"text/markdown"` is supported. See
   * [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
   *
   * @generated from field: string mime_type = 2;
   */
  mimeType = "";

  constructor(data?: PartialMessage<AlertPolicy_Documentation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Documentation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Documentation {
    return new AlertPolicy_Documentation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Documentation {
    return new AlertPolicy_Documentation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Documentation {
    return new AlertPolicy_Documentation().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Documentation | PlainMessage<AlertPolicy_Documentation> | undefined, b: AlertPolicy_Documentation | PlainMessage<AlertPolicy_Documentation> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Documentation, a, b);
  }
}

/**
 * A condition is a true/false test that determines when an alerting policy
 * should open an incident. If a condition evaluates to true, it signifies
 * that something is wrong.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition
 */
export class AlertPolicy_Condition extends Message<AlertPolicy_Condition> {
  /**
   * Required if the condition exists. The unique resource name for this
   * condition. Its format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
   *
   * `[CONDITION_ID]` is assigned by Cloud Monitoring when the
   * condition is created as part of a new or updated alerting policy.
   *
   * When calling the
   * [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
   * method, do not include the `name` field in the conditions of the
   * requested alerting policy. Cloud Monitoring creates the
   * condition identifiers and includes them in the new policy.
   *
   * When calling the
   * [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
   * method to update a policy, including a condition `name` causes the
   * existing condition to be updated. Conditions without names are added to
   * the updated policy. Existing conditions are deleted if they are not
   * updated.
   *
   * Best practice is to preserve `[CONDITION_ID]` if you make only small
   * changes, such as those to condition thresholds, durations, or trigger
   * values.  Otherwise, treat the change as a new condition and let the
   * existing condition be deleted.
   *
   * @generated from field: string name = 12;
   */
  name = "";

  /**
   * A short name or phrase used to identify the condition in dashboards,
   * notifications, and incidents. To avoid confusion, don't use the same
   * display name for multiple conditions in the same policy.
   *
   * @generated from field: string display_name = 6;
   */
  displayName = "";

  /**
   * Only one of the following condition types will be specified.
   *
   * @generated from oneof google.monitoring.v3.AlertPolicy.Condition.condition
   */
  condition: {
    /**
     * A condition that compares a time series against a threshold.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MetricThreshold condition_threshold = 1;
     */
    value: AlertPolicy_Condition_MetricThreshold;
    case: "conditionThreshold";
  } | {
    /**
     * A condition that checks that a time series continues to
     * receive new data points.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MetricAbsence condition_absent = 2;
     */
    value: AlertPolicy_Condition_MetricAbsence;
    case: "conditionAbsent";
  } | {
    /**
     * A condition that checks for log messages matching given constraints. If
     * set, no other conditions can be present.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.LogMatch condition_matched_log = 20;
     */
    value: AlertPolicy_Condition_LogMatch;
    case: "conditionMatchedLog";
  } | {
    /**
     * A condition that uses the Monitoring Query Language to define
     * alerts.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition condition_monitoring_query_language = 19;
     */
    value: AlertPolicy_Condition_MonitoringQueryLanguageCondition;
    case: "conditionMonitoringQueryLanguage";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AlertPolicy_Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 12, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "condition_threshold", kind: "message", T: AlertPolicy_Condition_MetricThreshold, oneof: "condition" },
    { no: 2, name: "condition_absent", kind: "message", T: AlertPolicy_Condition_MetricAbsence, oneof: "condition" },
    { no: 20, name: "condition_matched_log", kind: "message", T: AlertPolicy_Condition_LogMatch, oneof: "condition" },
    { no: 19, name: "condition_monitoring_query_language", kind: "message", T: AlertPolicy_Condition_MonitoringQueryLanguageCondition, oneof: "condition" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Condition {
    return new AlertPolicy_Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Condition {
    return new AlertPolicy_Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Condition {
    return new AlertPolicy_Condition().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Condition | PlainMessage<AlertPolicy_Condition> | undefined, b: AlertPolicy_Condition | PlainMessage<AlertPolicy_Condition> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Condition, a, b);
  }
}

/**
 * A condition control that determines how metric-threshold conditions
 * are evaluated when data stops arriving.
 * This control doesn't affect metric-absence policies.
 *
 * @generated from enum google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData
 */
export enum AlertPolicy_Condition_EvaluationMissingData {
  /**
   * An unspecified evaluation missing data option.  Equivalent to
   * EVALUATION_MISSING_DATA_NO_OP.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * If there is no data to evaluate the condition, then evaluate the
   * condition as false.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_INACTIVE = 1;
   */
  INACTIVE = 1,

  /**
   * If there is no data to evaluate the condition, then evaluate the
   * condition as true.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * Do not evaluate the condition to any value if there is no data.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_NO_OP = 3;
   */
  NO_OP = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AlertPolicy_Condition_EvaluationMissingData)
proto3.util.setEnumType(AlertPolicy_Condition_EvaluationMissingData, "google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData", [
  { no: 0, name: "EVALUATION_MISSING_DATA_UNSPECIFIED" },
  { no: 1, name: "EVALUATION_MISSING_DATA_INACTIVE" },
  { no: 2, name: "EVALUATION_MISSING_DATA_ACTIVE" },
  { no: 3, name: "EVALUATION_MISSING_DATA_NO_OP" },
]);

/**
 * Specifies how many time series must fail a predicate to trigger a
 * condition. If not specified, then a `{count: 1}` trigger is used.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.Trigger
 */
export class AlertPolicy_Condition_Trigger extends Message<AlertPolicy_Condition_Trigger> {
  /**
   * A type of trigger.
   *
   * @generated from oneof google.monitoring.v3.AlertPolicy.Condition.Trigger.type
   */
  type: {
    /**
     * The absolute number of time series that must fail
     * the predicate for the condition to be triggered.
     *
     * @generated from field: int32 count = 1;
     */
    value: number;
    case: "count";
  } | {
    /**
     * The percentage of time series that must fail the
     * predicate for the condition to be triggered.
     *
     * @generated from field: double percent = 2;
     */
    value: number;
    case: "percent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AlertPolicy_Condition_Trigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Condition.Trigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "type" },
    { no: 2, name: "percent", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Condition_Trigger {
    return new AlertPolicy_Condition_Trigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_Trigger {
    return new AlertPolicy_Condition_Trigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_Trigger {
    return new AlertPolicy_Condition_Trigger().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Condition_Trigger | PlainMessage<AlertPolicy_Condition_Trigger> | undefined, b: AlertPolicy_Condition_Trigger | PlainMessage<AlertPolicy_Condition_Trigger> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Condition_Trigger, a, b);
  }
}

/**
 * A condition type that compares a collection of time series
 * against a threshold.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MetricThreshold
 */
export class AlertPolicy_Condition_MetricThreshold extends Message<AlertPolicy_Condition_MetricThreshold> {
  /**
   * Required. A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies which time series should be compared with the threshold.
   *
   * The filter is similar to the one that is specified in the
   * [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
   * (that call is useful to verify the time series that will be retrieved /
   * processed). The filter must specify the metric type and the resource
   * type. Optionally, it can specify resource labels and metric labels.
   * This field must not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string filter = 2;
   */
  filter = "";

  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources). Multiple aggregations
   * are applied in the order specified.
   *
   * This field is similar to the one in the [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   * It is advisable to use the `ListTimeSeries` method when debugging this
   * field.
   *
   * @generated from field: repeated google.monitoring.v3.Aggregation aggregations = 8;
   */
  aggregations: Aggregation[] = [];

  /**
   * A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies a time series that should be used as the denominator of a
   * ratio that will be compared with the threshold. If a
   * `denominator_filter` is specified, the time series specified by the
   * `filter` field will be used as the numerator.
   *
   * The filter must specify the metric type and optionally may contain
   * restrictions on resource type, resource labels, and metric labels.
   * This field may not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string denominator_filter = 9;
   */
  denominatorFilter = "";

  /**
   * Specifies the alignment of data points in individual time series
   * selected by `denominatorFilter` as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources).
   *
   * When computing ratios, the `aggregations` and
   * `denominator_aggregations` fields must use the same alignment period
   * and produce time series that have the same periodicity and labels.
   *
   * @generated from field: repeated google.monitoring.v3.Aggregation denominator_aggregations = 10;
   */
  denominatorAggregations: Aggregation[] = [];

  /**
   * The comparison to apply between the time series (indicated by `filter`
   * and `aggregation`) and the threshold (indicated by `threshold_value`).
   * The comparison is applied on each time series, with the time series
   * on the left-hand side and the threshold on the right-hand side.
   *
   * Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
   *
   * @generated from field: google.monitoring.v3.ComparisonType comparison = 4;
   */
  comparison = ComparisonType.COMPARISON_UNSPECIFIED;

  /**
   * A value against which to compare the time series.
   *
   * @generated from field: double threshold_value = 5;
   */
  thresholdValue = 0;

  /**
   * The amount of time that a time series must violate the
   * threshold to be considered failing. Currently, only values
   * that are a multiple of a minute--e.g., 0, 60, 120, or 300
   * seconds--are supported. If an invalid value is given, an
   * error will be returned. When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying time series data
   * (which may also be affected by any alignments specified in the
   * `aggregations` field); a good duration is long enough so that a single
   * outlier does not generate spurious alerts, but short enough that
   * unhealthy states are detected and alerted on quickly.
   *
   * @generated from field: google.protobuf.Duration duration = 6;
   */
  duration?: Duration;

  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`,
   * or by the ratio, if `denominator_filter` and `denominator_aggregations`
   * are specified.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 7;
   */
  trigger?: AlertPolicy_Condition_Trigger;

  /**
   * A condition control that determines how metric-threshold conditions
   * are evaluated when data stops arriving.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData evaluation_missing_data = 11;
   */
  evaluationMissingData = AlertPolicy_Condition_EvaluationMissingData.UNSPECIFIED;

  constructor(data?: PartialMessage<AlertPolicy_Condition_MetricThreshold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Condition.MetricThreshold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "aggregations", kind: "message", T: Aggregation, repeated: true },
    { no: 9, name: "denominator_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "denominator_aggregations", kind: "message", T: Aggregation, repeated: true },
    { no: 4, name: "comparison", kind: "enum", T: proto3.getEnumType(ComparisonType) },
    { no: 5, name: "threshold_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "duration", kind: "message", T: Duration },
    { no: 7, name: "trigger", kind: "message", T: AlertPolicy_Condition_Trigger },
    { no: 11, name: "evaluation_missing_data", kind: "enum", T: proto3.getEnumType(AlertPolicy_Condition_EvaluationMissingData) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Condition_MetricThreshold {
    return new AlertPolicy_Condition_MetricThreshold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_MetricThreshold {
    return new AlertPolicy_Condition_MetricThreshold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_MetricThreshold {
    return new AlertPolicy_Condition_MetricThreshold().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Condition_MetricThreshold | PlainMessage<AlertPolicy_Condition_MetricThreshold> | undefined, b: AlertPolicy_Condition_MetricThreshold | PlainMessage<AlertPolicy_Condition_MetricThreshold> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Condition_MetricThreshold, a, b);
  }
}

/**
 * A condition type that checks that monitored resources
 * are reporting data. The configuration defines a metric and
 * a set of monitored resources. The predicate is considered in violation
 * when a time series for the specified metric of a monitored
 * resource does not include any data in the specified `duration`.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MetricAbsence
 */
export class AlertPolicy_Condition_MetricAbsence extends Message<AlertPolicy_Condition_MetricAbsence> {
  /**
   * Required. A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies which time series should be compared with the threshold.
   *
   * The filter is similar to the one that is specified in the
   * [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
   * (that call is useful to verify the time series that will be retrieved /
   * processed). The filter must specify the metric type and the resource
   * type. Optionally, it can specify resource labels and metric labels.
   * This field must not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string filter = 1;
   */
  filter = "";

  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources). Multiple aggregations
   * are applied in the order specified.
   *
   * This field is similar to the one in the [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   * It is advisable to use the `ListTimeSeries` method when debugging this
   * field.
   *
   * @generated from field: repeated google.monitoring.v3.Aggregation aggregations = 5;
   */
  aggregations: Aggregation[] = [];

  /**
   * The amount of time that a time series must fail to report new
   * data to be considered failing. The minimum value of this field
   * is 120 seconds. Larger values that are a multiple of a
   * minute--for example, 240 or 300 seconds--are supported.
   * If an invalid value is given, an
   * error will be returned. The `Duration.nanos` field is
   * ignored.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 3;
   */
  trigger?: AlertPolicy_Condition_Trigger;

  constructor(data?: PartialMessage<AlertPolicy_Condition_MetricAbsence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Condition.MetricAbsence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "aggregations", kind: "message", T: Aggregation, repeated: true },
    { no: 2, name: "duration", kind: "message", T: Duration },
    { no: 3, name: "trigger", kind: "message", T: AlertPolicy_Condition_Trigger },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Condition_MetricAbsence {
    return new AlertPolicy_Condition_MetricAbsence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_MetricAbsence {
    return new AlertPolicy_Condition_MetricAbsence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_MetricAbsence {
    return new AlertPolicy_Condition_MetricAbsence().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Condition_MetricAbsence | PlainMessage<AlertPolicy_Condition_MetricAbsence> | undefined, b: AlertPolicy_Condition_MetricAbsence | PlainMessage<AlertPolicy_Condition_MetricAbsence> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Condition_MetricAbsence, a, b);
  }
}

/**
 * A condition type that checks whether a log message in the [scoping
 * project](https://cloud.google.com/monitoring/api/v3#project_name)
 * satisfies the given filter. Logs from other projects in the metrics
 * scope are not evaluated.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.LogMatch
 */
export class AlertPolicy_Condition_LogMatch extends Message<AlertPolicy_Condition_LogMatch> {
  /**
   * Required. A logs-based filter. See [Advanced Logs
   * Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
   * for how this filter should be constructed.
   *
   * @generated from field: string filter = 1;
   */
  filter = "";

  /**
   * Optional. A map from a label key to an extractor expression, which is
   * used to extract the value for this label key. Each entry in this map is
   * a specification for how data should be extracted from log entries that
   * match `filter`. Each combination of extracted values is treated as a
   * separate rule for the purposes of triggering notifications. Label keys
   * and corresponding values can be used in notifications generated by this
   * condition.
   *
   * Please see [the documentation on logs-based metric
   * `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
   * for syntax and examples.
   *
   * @generated from field: map<string, string> label_extractors = 2;
   */
  labelExtractors: { [key: string]: string } = {};

  constructor(data?: PartialMessage<AlertPolicy_Condition_LogMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Condition.LogMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "label_extractors", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Condition_LogMatch {
    return new AlertPolicy_Condition_LogMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_LogMatch {
    return new AlertPolicy_Condition_LogMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_LogMatch {
    return new AlertPolicy_Condition_LogMatch().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Condition_LogMatch | PlainMessage<AlertPolicy_Condition_LogMatch> | undefined, b: AlertPolicy_Condition_LogMatch | PlainMessage<AlertPolicy_Condition_LogMatch> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Condition_LogMatch, a, b);
  }
}

/**
 * A condition type that allows alert policies to be defined using
 * [Monitoring Query Language](https://cloud.google.com/monitoring/mql).
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition
 */
export class AlertPolicy_Condition_MonitoringQueryLanguageCondition extends Message<AlertPolicy_Condition_MonitoringQueryLanguageCondition> {
  /**
   * [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
   * query that outputs a boolean stream.
   *
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * The amount of time that a time series must violate the
   * threshold to be considered failing. Currently, only values
   * that are a multiple of a minute--e.g., 0, 60, 120, or 300
   * seconds--are supported. If an invalid value is given, an
   * error will be returned. When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying time series data
   * (which may also be affected by any alignments specified in the
   * `aggregations` field); a good duration is long enough so that a single
   * outlier does not generate spurious alerts, but short enough that
   * unhealthy states are detected and alerted on quickly.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`,
   * or by the ratio, if `denominator_filter` and `denominator_aggregations`
   * are specified.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 3;
   */
  trigger?: AlertPolicy_Condition_Trigger;

  /**
   * A condition control that determines how metric-threshold conditions
   * are evaluated when data stops arriving.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData evaluation_missing_data = 4;
   */
  evaluationMissingData = AlertPolicy_Condition_EvaluationMissingData.UNSPECIFIED;

  constructor(data?: PartialMessage<AlertPolicy_Condition_MonitoringQueryLanguageCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "duration", kind: "message", T: Duration },
    { no: 3, name: "trigger", kind: "message", T: AlertPolicy_Condition_Trigger },
    { no: 4, name: "evaluation_missing_data", kind: "enum", T: proto3.getEnumType(AlertPolicy_Condition_EvaluationMissingData) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    return new AlertPolicy_Condition_MonitoringQueryLanguageCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    return new AlertPolicy_Condition_MonitoringQueryLanguageCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    return new AlertPolicy_Condition_MonitoringQueryLanguageCondition().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_Condition_MonitoringQueryLanguageCondition | PlainMessage<AlertPolicy_Condition_MonitoringQueryLanguageCondition> | undefined, b: AlertPolicy_Condition_MonitoringQueryLanguageCondition | PlainMessage<AlertPolicy_Condition_MonitoringQueryLanguageCondition> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_Condition_MonitoringQueryLanguageCondition, a, b);
  }
}

/**
 * Control over how the notification channels in `notification_channels`
 * are notified when this alert fires.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.AlertStrategy
 */
export class AlertPolicy_AlertStrategy extends Message<AlertPolicy_AlertStrategy> {
  /**
   * Required for alert policies with a `LogMatch` condition.
   *
   * This limit is not implemented for alert policies that are not log-based.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit notification_rate_limit = 1;
   */
  notificationRateLimit?: AlertPolicy_AlertStrategy_NotificationRateLimit;

  /**
   * If an alert policy that was active has no data for this long, any open
   * incidents will close
   *
   * @generated from field: google.protobuf.Duration auto_close = 3;
   */
  autoClose?: Duration;

  constructor(data?: PartialMessage<AlertPolicy_AlertStrategy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.AlertStrategy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "notification_rate_limit", kind: "message", T: AlertPolicy_AlertStrategy_NotificationRateLimit },
    { no: 3, name: "auto_close", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_AlertStrategy {
    return new AlertPolicy_AlertStrategy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_AlertStrategy {
    return new AlertPolicy_AlertStrategy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_AlertStrategy {
    return new AlertPolicy_AlertStrategy().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_AlertStrategy | PlainMessage<AlertPolicy_AlertStrategy> | undefined, b: AlertPolicy_AlertStrategy | PlainMessage<AlertPolicy_AlertStrategy> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_AlertStrategy, a, b);
  }
}

/**
 * Control over the rate of notifications sent to this alert policy's
 * notification channels.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit
 */
export class AlertPolicy_AlertStrategy_NotificationRateLimit extends Message<AlertPolicy_AlertStrategy_NotificationRateLimit> {
  /**
   * Not more than one notification per `period`.
   *
   * @generated from field: google.protobuf.Duration period = 1;
   */
  period?: Duration;

  constructor(data?: PartialMessage<AlertPolicy_AlertStrategy_NotificationRateLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "period", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertPolicy_AlertStrategy_NotificationRateLimit {
    return new AlertPolicy_AlertStrategy_NotificationRateLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertPolicy_AlertStrategy_NotificationRateLimit {
    return new AlertPolicy_AlertStrategy_NotificationRateLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertPolicy_AlertStrategy_NotificationRateLimit {
    return new AlertPolicy_AlertStrategy_NotificationRateLimit().fromJsonString(jsonString, options);
  }

  static equals(a: AlertPolicy_AlertStrategy_NotificationRateLimit | PlainMessage<AlertPolicy_AlertStrategy_NotificationRateLimit> | undefined, b: AlertPolicy_AlertStrategy_NotificationRateLimit | PlainMessage<AlertPolicy_AlertStrategy_NotificationRateLimit> | undefined): boolean {
    return proto3.util.equals(AlertPolicy_AlertStrategy_NotificationRateLimit, a, b);
  }
}

