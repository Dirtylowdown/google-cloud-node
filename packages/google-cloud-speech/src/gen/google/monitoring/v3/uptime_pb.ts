// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/uptime.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";
import { MonitoredResource } from "../../api/monitored_resource_pb.js";

/**
 * The regions from which an Uptime check can be run.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckRegion
 */
export enum UptimeCheckRegion {
  /**
   * Default value if no region is specified. Will result in Uptime checks
   * running from all regions.
   *
   * @generated from enum value: REGION_UNSPECIFIED = 0;
   */
  REGION_UNSPECIFIED = 0,

  /**
   * Allows checks to run from locations within the United States of America.
   *
   * @generated from enum value: USA = 1;
   */
  USA = 1,

  /**
   * Allows checks to run from locations within the continent of Europe.
   *
   * @generated from enum value: EUROPE = 2;
   */
  EUROPE = 2,

  /**
   * Allows checks to run from locations within the continent of South
   * America.
   *
   * @generated from enum value: SOUTH_AMERICA = 3;
   */
  SOUTH_AMERICA = 3,

  /**
   * Allows checks to run from locations within the Asia Pacific area (ex:
   * Singapore).
   *
   * @generated from enum value: ASIA_PACIFIC = 4;
   */
  ASIA_PACIFIC = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(UptimeCheckRegion)
proto3.util.setEnumType(UptimeCheckRegion, "google.monitoring.v3.UptimeCheckRegion", [
  { no: 0, name: "REGION_UNSPECIFIED" },
  { no: 1, name: "USA" },
  { no: 2, name: "EUROPE" },
  { no: 3, name: "SOUTH_AMERICA" },
  { no: 4, name: "ASIA_PACIFIC" },
]);

/**
 * The supported resource types that can be used as values of
 * `group_resource.resource_type`.
 * `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
 * The resource types `gae_app` and `uptime_url` are not valid here because
 * group checks on App Engine modules and URLs are not allowed.
 *
 * @generated from enum google.monitoring.v3.GroupResourceType
 */
export enum GroupResourceType {
  /**
   * Default value (not valid).
   *
   * @generated from enum value: RESOURCE_TYPE_UNSPECIFIED = 0;
   */
  RESOURCE_TYPE_UNSPECIFIED = 0,

  /**
   * A group of instances from Google Cloud Platform (GCP) or
   * Amazon Web Services (AWS).
   *
   * @generated from enum value: INSTANCE = 1;
   */
  INSTANCE = 1,

  /**
   * A group of Amazon ELB load balancers.
   *
   * @generated from enum value: AWS_ELB_LOAD_BALANCER = 2;
   */
  AWS_ELB_LOAD_BALANCER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(GroupResourceType)
proto3.util.setEnumType(GroupResourceType, "google.monitoring.v3.GroupResourceType", [
  { no: 0, name: "RESOURCE_TYPE_UNSPECIFIED" },
  { no: 1, name: "INSTANCE" },
  { no: 2, name: "AWS_ELB_LOAD_BALANCER" },
]);

/**
 * An internal checker allows Uptime checks to run on private/internal GCP
 * resources.
 *
 * @generated from message google.monitoring.v3.InternalChecker
 * @deprecated
 */
export class InternalChecker extends Message<InternalChecker> {
  /**
   * A unique resource name for this InternalChecker. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
   *
   * `[PROJECT_ID_OR_NUMBER]` is the Stackdriver Workspace project for the
   * Uptime check config associated with the internal checker.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The checker's human-readable name. The display name
   * should be unique within a Stackdriver Workspace in order to make it easier
   * to identify; however, uniqueness is not enforced.
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
   * internal resource lives (ex: "default").
   *
   * @generated from field: string network = 3;
   */
  network = "";

  /**
   * The GCP zone the Uptime check should egress from. Only respected for
   * internal Uptime checks, where internal_network is specified.
   *
   * @generated from field: string gcp_zone = 4;
   */
  gcpZone = "";

  /**
   * The GCP project ID where the internal checker lives. Not necessary
   * the same as the Workspace project.
   *
   * @generated from field: string peer_project_id = 6;
   */
  peerProjectId = "";

  /**
   * The current operational state of the internal checker.
   *
   * @generated from field: google.monitoring.v3.InternalChecker.State state = 7;
   */
  state = InternalChecker_State.UNSPECIFIED;

  constructor(data?: PartialMessage<InternalChecker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.InternalChecker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gcp_zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "peer_project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "state", kind: "enum", T: proto3.getEnumType(InternalChecker_State) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InternalChecker {
    return new InternalChecker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InternalChecker {
    return new InternalChecker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InternalChecker {
    return new InternalChecker().fromJsonString(jsonString, options);
  }

  static equals(a: InternalChecker | PlainMessage<InternalChecker> | undefined, b: InternalChecker | PlainMessage<InternalChecker> | undefined): boolean {
    return proto3.util.equals(InternalChecker, a, b);
  }
}

/**
 * Operational states for an internal checker.
 *
 * @generated from enum google.monitoring.v3.InternalChecker.State
 */
export enum InternalChecker_State {
  /**
   * An internal checker should never be in the unspecified state.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The checker is being created, provisioned, and configured. A checker in
   * this state can be returned by `ListInternalCheckers` or
   * `GetInternalChecker`, as well as by examining the [long running
   * Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
   * that created it.
   *
   * @generated from enum value: CREATING = 1;
   */
  CREATING = 1,

  /**
   * The checker is running and available for use. A checker in this state
   * can be returned by `ListInternalCheckers` or `GetInternalChecker` as
   * well as by examining the [long running
   * Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
   * that created it.
   * If a checker is being torn down, it is neither visible nor usable, so
   * there is no "deleting" or "down" state.
   *
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InternalChecker_State)
proto3.util.setEnumType(InternalChecker_State, "google.monitoring.v3.InternalChecker.State", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "CREATING" },
  { no: 2, name: "RUNNING" },
]);

/**
 * This message configures which resources and services to monitor for
 * availability.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig
 */
export class UptimeCheckConfig extends Message<UptimeCheckConfig> {
  /**
   * A unique resource name for this Uptime check configuration. The format is:
   *
   *      projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
   *
   * `[PROJECT_ID_OR_NUMBER]` is the Workspace host project associated with the
   * Uptime check.
   *
   * This field should be omitted when creating the Uptime check configuration;
   * on create, the resource name is assigned by the server and included in the
   * response.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A human-friendly name for the Uptime check configuration. The display name
   * should be unique within a Stackdriver Workspace in order to make it easier
   * to identify; however, uniqueness is not enforced. Required.
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * The resource the check is checking. Required.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.resource
   */
  resource: {
    /**
     * The [monitored
     * resource](https://cloud.google.com/monitoring/api/resources) associated
     * with the configuration.
     * The following monitored resource types are valid for this field:
     *   `uptime_url`,
     *   `gce_instance`,
     *   `gae_app`,
     *   `aws_ec2_instance`,
     *   `aws_elb_load_balancer`
     *   `k8s_service`
     *
     * @generated from field: google.api.MonitoredResource monitored_resource = 3;
     */
    value: MonitoredResource;
    case: "monitoredResource";
  } | {
    /**
     * The group resource associated with the configuration.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.ResourceGroup resource_group = 4;
     */
    value: UptimeCheckConfig_ResourceGroup;
    case: "resourceGroup";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The type of Uptime check request.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.check_request_type
   */
  checkRequestType: {
    /**
     * Contains information needed to make an HTTP or HTTPS check.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck http_check = 5;
     */
    value: UptimeCheckConfig_HttpCheck;
    case: "httpCheck";
  } | {
    /**
     * Contains information needed to make a TCP check.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.TcpCheck tcp_check = 6;
     */
    value: UptimeCheckConfig_TcpCheck;
    case: "tcpCheck";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * How often, in seconds, the Uptime check is performed.
   * Currently, the only supported values are `60s` (1 minute), `300s`
   * (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
   * defaults to `60s`.
   *
   * @generated from field: google.protobuf.Duration period = 7;
   */
  period?: Duration;

  /**
   * The maximum amount of time to wait for the request to complete (must be
   * between 1 and 60 seconds). Required.
   *
   * @generated from field: google.protobuf.Duration timeout = 8;
   */
  timeout?: Duration;

  /**
   * The content that is expected to appear in the data returned by the target
   * server against which the check is run.  Currently, only the first entry
   * in the `content_matchers` list is supported, and additional entries will
   * be ignored. This field is optional and should only be specified if a
   * content match is required as part of the/ Uptime check.
   *
   * @generated from field: repeated google.monitoring.v3.UptimeCheckConfig.ContentMatcher content_matchers = 9;
   */
  contentMatchers: UptimeCheckConfig_ContentMatcher[] = [];

  /**
   * The list of regions from which the check will be run.
   * Some regions contain one location, and others contain more than one.
   * If this field is specified, enough regions must be provided to include a
   * minimum of 3 locations.  Not specifying this field will result in Uptime
   * checks running from all available regions.
   *
   * @generated from field: repeated google.monitoring.v3.UptimeCheckRegion selected_regions = 10;
   */
  selectedRegions: UptimeCheckRegion[] = [];

  /**
   * If this is `true`, then checks are made only from the 'internal_checkers'.
   * If it is `false`, then checks are made only from the 'selected_regions'.
   * It is an error to provide 'selected_regions' when is_internal is `true`,
   * or to provide 'internal_checkers' when is_internal is `false`.
   *
   * @generated from field: bool is_internal = 15 [deprecated = true];
   * @deprecated
   */
  isInternal = false;

  /**
   * The internal checkers that this check will egress from. If `is_internal` is
   * `true` and this list is empty, the check will egress from all the
   * InternalCheckers configured for the project that owns this
   * `UptimeCheckConfig`.
   *
   * @generated from field: repeated google.monitoring.v3.InternalChecker internal_checkers = 14 [deprecated = true];
   * @deprecated
   */
  internalCheckers: InternalChecker[] = [];

  constructor(data?: PartialMessage<UptimeCheckConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "monitored_resource", kind: "message", T: MonitoredResource, oneof: "resource" },
    { no: 4, name: "resource_group", kind: "message", T: UptimeCheckConfig_ResourceGroup, oneof: "resource" },
    { no: 5, name: "http_check", kind: "message", T: UptimeCheckConfig_HttpCheck, oneof: "check_request_type" },
    { no: 6, name: "tcp_check", kind: "message", T: UptimeCheckConfig_TcpCheck, oneof: "check_request_type" },
    { no: 7, name: "period", kind: "message", T: Duration },
    { no: 8, name: "timeout", kind: "message", T: Duration },
    { no: 9, name: "content_matchers", kind: "message", T: UptimeCheckConfig_ContentMatcher, repeated: true },
    { no: 10, name: "selected_regions", kind: "enum", T: proto3.getEnumType(UptimeCheckRegion), repeated: true },
    { no: 15, name: "is_internal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "internal_checkers", kind: "message", T: InternalChecker, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckConfig {
    return new UptimeCheckConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckConfig {
    return new UptimeCheckConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckConfig {
    return new UptimeCheckConfig().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckConfig | PlainMessage<UptimeCheckConfig> | undefined, b: UptimeCheckConfig | PlainMessage<UptimeCheckConfig> | undefined): boolean {
    return proto3.util.equals(UptimeCheckConfig, a, b);
  }
}

/**
 * The resource submessage for group checks. It can be used instead of a
 * monitored resource, when multiple resources are being monitored.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.ResourceGroup
 */
export class UptimeCheckConfig_ResourceGroup extends Message<UptimeCheckConfig_ResourceGroup> {
  /**
   * The group of resources being monitored. Should be only the `[GROUP_ID]`,
   * and not the full-path
   * `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
   *
   * @generated from field: string group_id = 1;
   */
  groupId = "";

  /**
   * The resource type of the group members.
   *
   * @generated from field: google.monitoring.v3.GroupResourceType resource_type = 2;
   */
  resourceType = GroupResourceType.RESOURCE_TYPE_UNSPECIFIED;

  constructor(data?: PartialMessage<UptimeCheckConfig_ResourceGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckConfig.ResourceGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource_type", kind: "enum", T: proto3.getEnumType(GroupResourceType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckConfig_ResourceGroup {
    return new UptimeCheckConfig_ResourceGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckConfig_ResourceGroup {
    return new UptimeCheckConfig_ResourceGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckConfig_ResourceGroup {
    return new UptimeCheckConfig_ResourceGroup().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckConfig_ResourceGroup | PlainMessage<UptimeCheckConfig_ResourceGroup> | undefined, b: UptimeCheckConfig_ResourceGroup | PlainMessage<UptimeCheckConfig_ResourceGroup> | undefined): boolean {
    return proto3.util.equals(UptimeCheckConfig_ResourceGroup, a, b);
  }
}

/**
 * Information involved in an HTTP/HTTPS Uptime check request.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.HttpCheck
 */
export class UptimeCheckConfig_HttpCheck extends Message<UptimeCheckConfig_HttpCheck> {
  /**
   * The HTTP request method to use for the check. If set to
   * `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;
   */
  requestMethod = UptimeCheckConfig_HttpCheck_RequestMethod.METHOD_UNSPECIFIED;

  /**
   * If `true`, use HTTPS instead of HTTP to run the check.
   *
   * @generated from field: bool use_ssl = 1;
   */
  useSsl = false;

  /**
   * Optional (defaults to "/"). The path to the page against which to run
   * the check. Will be combined with the `host` (specified within the
   * `monitored_resource`) and `port` to construct the full URL. If the
   * provided path does not begin with "/", a "/" will be prepended
   * automatically.
   *
   * @generated from field: string path = 2;
   */
  path = "";

  /**
   * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
   * `use_ssl` is `true`). The TCP port on the HTTP server against which to
   * run the check. Will be combined with host (specified within the
   * `monitored_resource`) and `path` to construct the full URL.
   *
   * @generated from field: int32 port = 3;
   */
  port = 0;

  /**
   * The authentication information. Optional when creating an HTTP check;
   * defaults to empty.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;
   */
  authInfo?: UptimeCheckConfig_HttpCheck_BasicAuthentication;

  /**
   * Boolean specifying whether to encrypt the header information.
   * Encryption should be specified for any headers related to authentication
   * that you do not wish to be seen when retrieving the configuration. The
   * server will be responsible for encrypting the headers.
   * On Get/List calls, if `mask_headers` is set to `true` then the headers
   * will be obscured with `******.`
   *
   * @generated from field: bool mask_headers = 5;
   */
  maskHeaders = false;

  /**
   * The list of headers to send as part of the Uptime check request.
   * If two headers have the same key and different values, they should
   * be entered as a single header, with the value being a comma-separated
   * list of all the desired values as described at
   * https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
   * Entering two separate headers with the same key in a Create call will
   * cause the first to be overwritten by the second.
   * The maximum number of headers allowed is 100.
   *
   * @generated from field: map<string, string> headers = 6;
   */
  headers: { [key: string]: string } = {};

  /**
   * The content type header to use for the check. The following
   * configurations result in errors:
   * 1. Content type is specified in both the `headers` field and the
   * `content_type` field.
   * 2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
   * 3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
   * 4. Request method is `POST` and a "Content-Type" header is provided via
   * `headers` field. The `content_type` field should be used instead.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;
   */
  contentType = UptimeCheckConfig_HttpCheck_ContentType.TYPE_UNSPECIFIED;

  /**
   * Boolean specifying whether to include SSL certificate validation as a
   * part of the Uptime check. Only applies to checks where
   * `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
   * setting `validate_ssl` to `true` has no effect.
   *
   * @generated from field: bool validate_ssl = 7;
   */
  validateSsl = false;

  /**
   * The request body associated with the HTTP POST request. If `content_type`
   * is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
   * provide a `Content-Length` header via the `headers` field or the API will
   * do so. If the `request_method` is `GET` and `body` is not empty, the API
   * will return an error. The maximum byte size is 1 megabyte. Note: As with
   * all `bytes` fields, JSON representations are base64 encoded. e.g.:
   * "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is
   * "Zm9vJTI1M0RiYXI=".
   *
   * @generated from field: bytes body = 10;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<UptimeCheckConfig_HttpCheck>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckConfig.HttpCheck";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "request_method", kind: "enum", T: proto3.getEnumType(UptimeCheckConfig_HttpCheck_RequestMethod) },
    { no: 1, name: "use_ssl", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "auth_info", kind: "message", T: UptimeCheckConfig_HttpCheck_BasicAuthentication },
    { no: 5, name: "mask_headers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "headers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 9, name: "content_type", kind: "enum", T: proto3.getEnumType(UptimeCheckConfig_HttpCheck_ContentType) },
    { no: 7, name: "validate_ssl", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckConfig_HttpCheck {
    return new UptimeCheckConfig_HttpCheck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckConfig_HttpCheck {
    return new UptimeCheckConfig_HttpCheck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckConfig_HttpCheck {
    return new UptimeCheckConfig_HttpCheck().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckConfig_HttpCheck | PlainMessage<UptimeCheckConfig_HttpCheck> | undefined, b: UptimeCheckConfig_HttpCheck | PlainMessage<UptimeCheckConfig_HttpCheck> | undefined): boolean {
    return proto3.util.equals(UptimeCheckConfig_HttpCheck, a, b);
  }
}

/**
 * The HTTP request method options.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod
 */
export enum UptimeCheckConfig_HttpCheck_RequestMethod {
  /**
   * No request method specified.
   *
   * @generated from enum value: METHOD_UNSPECIFIED = 0;
   */
  METHOD_UNSPECIFIED = 0,

  /**
   * GET request.
   *
   * @generated from enum value: GET = 1;
   */
  GET = 1,

  /**
   * POST request.
   *
   * @generated from enum value: POST = 2;
   */
  POST = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UptimeCheckConfig_HttpCheck_RequestMethod)
proto3.util.setEnumType(UptimeCheckConfig_HttpCheck_RequestMethod, "google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod", [
  { no: 0, name: "METHOD_UNSPECIFIED" },
  { no: 1, name: "GET" },
  { no: 2, name: "POST" },
]);

/**
 * Header options corresponding to the content type of a HTTP request body.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType
 */
export enum UptimeCheckConfig_HttpCheck_ContentType {
  /**
   * No content type specified.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * `body` is in URL-encoded form. Equivalent to setting the `Content-Type`
   * to `application/x-www-form-urlencoded` in the HTTP request.
   *
   * @generated from enum value: URL_ENCODED = 1;
   */
  URL_ENCODED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(UptimeCheckConfig_HttpCheck_ContentType)
proto3.util.setEnumType(UptimeCheckConfig_HttpCheck_ContentType, "google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType", [
  { no: 0, name: "TYPE_UNSPECIFIED" },
  { no: 1, name: "URL_ENCODED" },
]);

/**
 * The authentication parameters to provide to the specified resource or
 * URL that requires a username and password. Currently, only
 * [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
 * supported in Uptime checks.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication
 */
export class UptimeCheckConfig_HttpCheck_BasicAuthentication extends Message<UptimeCheckConfig_HttpCheck_BasicAuthentication> {
  /**
   * The username to use when authenticating with the HTTP server.
   *
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * The password to use when authenticating with the HTTP server.
   *
   * @generated from field: string password = 2;
   */
  password = "";

  constructor(data?: PartialMessage<UptimeCheckConfig_HttpCheck_BasicAuthentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    return new UptimeCheckConfig_HttpCheck_BasicAuthentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    return new UptimeCheckConfig_HttpCheck_BasicAuthentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    return new UptimeCheckConfig_HttpCheck_BasicAuthentication().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckConfig_HttpCheck_BasicAuthentication | PlainMessage<UptimeCheckConfig_HttpCheck_BasicAuthentication> | undefined, b: UptimeCheckConfig_HttpCheck_BasicAuthentication | PlainMessage<UptimeCheckConfig_HttpCheck_BasicAuthentication> | undefined): boolean {
    return proto3.util.equals(UptimeCheckConfig_HttpCheck_BasicAuthentication, a, b);
  }
}

/**
 * Information required for a TCP Uptime check request.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.TcpCheck
 */
export class UptimeCheckConfig_TcpCheck extends Message<UptimeCheckConfig_TcpCheck> {
  /**
   * The TCP port on the server against which to run the check. Will be
   * combined with host (specified within the `monitored_resource`) to
   * construct the full URL. Required.
   *
   * @generated from field: int32 port = 1;
   */
  port = 0;

  constructor(data?: PartialMessage<UptimeCheckConfig_TcpCheck>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckConfig.TcpCheck";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckConfig_TcpCheck {
    return new UptimeCheckConfig_TcpCheck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckConfig_TcpCheck {
    return new UptimeCheckConfig_TcpCheck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckConfig_TcpCheck {
    return new UptimeCheckConfig_TcpCheck().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckConfig_TcpCheck | PlainMessage<UptimeCheckConfig_TcpCheck> | undefined, b: UptimeCheckConfig_TcpCheck | PlainMessage<UptimeCheckConfig_TcpCheck> | undefined): boolean {
    return proto3.util.equals(UptimeCheckConfig_TcpCheck, a, b);
  }
}

/**
 * Optional. Used to perform content matching. This allows matching based on
 * substrings and regular expressions, together with their negations. Only the
 * first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
 * 1&nbsp;MB of a TCP check's response) are examined for purposes of content
 * matching.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.ContentMatcher
 */
export class UptimeCheckConfig_ContentMatcher extends Message<UptimeCheckConfig_ContentMatcher> {
  /**
   * String or regex content to match. Maximum 1024 bytes. An empty `content`
   * string indicates no content matching is to be performed.
   *
   * @generated from field: string content = 1;
   */
  content = "";

  /**
   * The type of content matcher that will be applied to the server output,
   * compared to the `content` string when the check is run.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption matcher = 2;
   */
  matcher = UptimeCheckConfig_ContentMatcher_ContentMatcherOption.CONTENT_MATCHER_OPTION_UNSPECIFIED;

  constructor(data?: PartialMessage<UptimeCheckConfig_ContentMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckConfig.ContentMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "matcher", kind: "enum", T: proto3.getEnumType(UptimeCheckConfig_ContentMatcher_ContentMatcherOption) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckConfig_ContentMatcher {
    return new UptimeCheckConfig_ContentMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckConfig_ContentMatcher {
    return new UptimeCheckConfig_ContentMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckConfig_ContentMatcher {
    return new UptimeCheckConfig_ContentMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckConfig_ContentMatcher | PlainMessage<UptimeCheckConfig_ContentMatcher> | undefined, b: UptimeCheckConfig_ContentMatcher | PlainMessage<UptimeCheckConfig_ContentMatcher> | undefined): boolean {
    return proto3.util.equals(UptimeCheckConfig_ContentMatcher, a, b);
  }
}

/**
 * Options to perform content matching.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption
 */
export enum UptimeCheckConfig_ContentMatcher_ContentMatcherOption {
  /**
   * No content matcher type specified (maintained for backward
   * compatibility, but deprecated for future use).
   * Treated as `CONTAINS_STRING`.
   *
   * @generated from enum value: CONTENT_MATCHER_OPTION_UNSPECIFIED = 0;
   */
  CONTENT_MATCHER_OPTION_UNSPECIFIED = 0,

  /**
   * Selects substring matching. The match succeeds if the output contains
   * the `content` string.  This is the default value for checks without
   * a `matcher` option, or where the value of `matcher` is
   * `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
   *
   * @generated from enum value: CONTAINS_STRING = 1;
   */
  CONTAINS_STRING = 1,

  /**
   * Selects negation of substring matching. The match succeeds if the
   * output does _NOT_ contain the `content` string.
   *
   * @generated from enum value: NOT_CONTAINS_STRING = 2;
   */
  NOT_CONTAINS_STRING = 2,

  /**
   * Selects regular-expression matching. The match succeeds of the output
   * matches the regular expression specified in the `content` string.
   * Regex matching is only supported for HTTP/HTTPS checks.
   *
   * @generated from enum value: MATCHES_REGEX = 3;
   */
  MATCHES_REGEX = 3,

  /**
   * Selects negation of regular-expression matching. The match succeeds if
   * the output does _NOT_ match the regular expression specified in the
   * `content` string. Regex matching is only supported for HTTP/HTTPS
   * checks.
   *
   * @generated from enum value: NOT_MATCHES_REGEX = 4;
   */
  NOT_MATCHES_REGEX = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(UptimeCheckConfig_ContentMatcher_ContentMatcherOption)
proto3.util.setEnumType(UptimeCheckConfig_ContentMatcher_ContentMatcherOption, "google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption", [
  { no: 0, name: "CONTENT_MATCHER_OPTION_UNSPECIFIED" },
  { no: 1, name: "CONTAINS_STRING" },
  { no: 2, name: "NOT_CONTAINS_STRING" },
  { no: 3, name: "MATCHES_REGEX" },
  { no: 4, name: "NOT_MATCHES_REGEX" },
]);

/**
 * Contains the region, location, and list of IP
 * addresses where checkers in the location run from.
 *
 * @generated from message google.monitoring.v3.UptimeCheckIp
 */
export class UptimeCheckIp extends Message<UptimeCheckIp> {
  /**
   * A broad region category in which the IP address is located.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckRegion region = 1;
   */
  region = UptimeCheckRegion.REGION_UNSPECIFIED;

  /**
   * A more specific location within the region that typically encodes
   * a particular city/town/metro (and its containing state/province or country)
   * within the broader umbrella region category.
   *
   * @generated from field: string location = 2;
   */
  location = "";

  /**
   * The IP address from which the Uptime check originates. This is a fully
   * specified IP address (not an IP address range). Most IP addresses, as of
   * this publication, are in IPv4 format; however, one should not rely on the
   * IP addresses being in IPv4 format indefinitely, and should support
   * interpreting this field in either IPv4 or IPv6 format.
   *
   * @generated from field: string ip_address = 3;
   */
  ipAddress = "";

  constructor(data?: PartialMessage<UptimeCheckIp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.UptimeCheckIp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "region", kind: "enum", T: proto3.getEnumType(UptimeCheckRegion) },
    { no: 2, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ip_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UptimeCheckIp {
    return new UptimeCheckIp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UptimeCheckIp {
    return new UptimeCheckIp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UptimeCheckIp {
    return new UptimeCheckIp().fromJsonString(jsonString, options);
  }

  static equals(a: UptimeCheckIp | PlainMessage<UptimeCheckIp> | undefined, b: UptimeCheckIp | PlainMessage<UptimeCheckIp> | undefined): boolean {
    return proto3.util.equals(UptimeCheckIp, a, b);
  }
}

