// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/metric.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { TimeInterval, TypedValue } from "./common_pb.js";
import { Metric, MetricDescriptor_MetricKind, MetricDescriptor_ValueType } from "../../api/metric_pb.js";
import { MonitoredResource, MonitoredResourceMetadata } from "../../api/monitored_resource_pb.js";
import { LabelDescriptor } from "../../api/label_pb.js";

/**
 * A single data point in a time series.
 *
 * @generated from message google.monitoring.v3.Point
 */
export class Point extends Message<Point> {
  /**
   * The time interval to which the data point applies.  For `GAUGE` metrics,
   * the start time is optional, but if it is supplied, it must equal the
   * end time.  For `DELTA` metrics, the start
   * and end time should specify a non-zero interval, with subsequent points
   * specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
   * metrics, the start and end time should specify a non-zero interval, with
   * subsequent points specifying the same start time and increasing end times,
   * until an event resets the cumulative value to zero and sets a new start
   * time for the following points.
   *
   * @generated from field: google.monitoring.v3.TimeInterval interval = 1;
   */
  interval?: TimeInterval;

  /**
   * The value of the data point.
   *
   * @generated from field: google.monitoring.v3.TypedValue value = 2;
   */
  value?: TypedValue;

  constructor(data?: PartialMessage<Point>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Point";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interval", kind: "message", T: TimeInterval },
    { no: 2, name: "value", kind: "message", T: TypedValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Point {
    return new Point().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Point {
    return new Point().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Point {
    return new Point().fromJsonString(jsonString, options);
  }

  static equals(a: Point | PlainMessage<Point> | undefined, b: Point | PlainMessage<Point> | undefined): boolean {
    return proto3.util.equals(Point, a, b);
  }
}

/**
 * A collection of data points that describes the time-varying values
 * of a metric. A time series is identified by a combination of a
 * fully-specified monitored resource and a fully-specified metric.
 * This type is used for both listing and creating time series.
 *
 * @generated from message google.monitoring.v3.TimeSeries
 */
export class TimeSeries extends Message<TimeSeries> {
  /**
   * The associated metric. A fully-specified metric used to identify the time
   * series.
   *
   * @generated from field: google.api.Metric metric = 1;
   */
  metric?: Metric;

  /**
   * The associated monitored resource.  Custom metrics can use only certain
   * monitored resource types in their time series data. For more information,
   * see [Monitored resources for custom
   * metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
   *
   * @generated from field: google.api.MonitoredResource resource = 2;
   */
  resource?: MonitoredResource;

  /**
   * Output only. The associated monitored resource metadata. When reading a
   * time series, this field will include metadata labels that are explicitly
   * named in the reduction. When creating a time series, this field is ignored.
   *
   * @generated from field: google.api.MonitoredResourceMetadata metadata = 7;
   */
  metadata?: MonitoredResourceMetadata;

  /**
   * The metric kind of the time series. When listing time series, this metric
   * kind might be different from the metric kind of the associated metric if
   * this time series is an alignment or reduction of other time series.
   *
   * When creating a time series, this field is optional. If present, it must be
   * the same as the metric kind of the associated metric. If the associated
   * metric's descriptor must be auto-created, then this field specifies the
   * metric kind of the new descriptor and must be either `GAUGE` (the default)
   * or `CUMULATIVE`.
   *
   * @generated from field: google.api.MetricDescriptor.MetricKind metric_kind = 3;
   */
  metricKind = MetricDescriptor_MetricKind.METRIC_KIND_UNSPECIFIED;

  /**
   * The value type of the time series. When listing time series, this value
   * type might be different from the value type of the associated metric if
   * this time series is an alignment or reduction of other time series.
   *
   * When creating a time series, this field is optional. If present, it must be
   * the same as the type of the data in the `points` field.
   *
   * @generated from field: google.api.MetricDescriptor.ValueType value_type = 4;
   */
  valueType = MetricDescriptor_ValueType.VALUE_TYPE_UNSPECIFIED;

  /**
   * The data points of this time series. When listing time series, points are
   * returned in reverse time order.
   *
   * When creating a time series, this field must contain exactly one point and
   * the point's type must be the same as the value type of the associated
   * metric. If the associated metric's descriptor must be auto-created, then
   * the value type of the descriptor is determined by the point's type, which
   * must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
   *
   * @generated from field: repeated google.monitoring.v3.Point points = 5;
   */
  points: Point[] = [];

  /**
   * The units in which the metric value is reported. It is only applicable
   * if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
   * defines the representation of the stored metric values.
   *
   * @generated from field: string unit = 8;
   */
  unit = "";

  constructor(data?: PartialMessage<TimeSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metric", kind: "message", T: Metric },
    { no: 2, name: "resource", kind: "message", T: MonitoredResource },
    { no: 7, name: "metadata", kind: "message", T: MonitoredResourceMetadata },
    { no: 3, name: "metric_kind", kind: "enum", T: proto3.getEnumType(MetricDescriptor_MetricKind) },
    { no: 4, name: "value_type", kind: "enum", T: proto3.getEnumType(MetricDescriptor_ValueType) },
    { no: 5, name: "points", kind: "message", T: Point, repeated: true },
    { no: 8, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries {
    return new TimeSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries | PlainMessage<TimeSeries> | undefined, b: TimeSeries | PlainMessage<TimeSeries> | undefined): boolean {
    return proto3.util.equals(TimeSeries, a, b);
  }
}

/**
 * A descriptor for the labels and points in a time series.
 *
 * @generated from message google.monitoring.v3.TimeSeriesDescriptor
 */
export class TimeSeriesDescriptor extends Message<TimeSeriesDescriptor> {
  /**
   * Descriptors for the labels.
   *
   * @generated from field: repeated google.api.LabelDescriptor label_descriptors = 1;
   */
  labelDescriptors: LabelDescriptor[] = [];

  /**
   * Descriptors for the point data value columns.
   *
   * @generated from field: repeated google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor point_descriptors = 5;
   */
  pointDescriptors: TimeSeriesDescriptor_ValueDescriptor[] = [];

  constructor(data?: PartialMessage<TimeSeriesDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeSeriesDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label_descriptors", kind: "message", T: LabelDescriptor, repeated: true },
    { no: 5, name: "point_descriptors", kind: "message", T: TimeSeriesDescriptor_ValueDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesDescriptor {
    return new TimeSeriesDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesDescriptor {
    return new TimeSeriesDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesDescriptor {
    return new TimeSeriesDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeriesDescriptor | PlainMessage<TimeSeriesDescriptor> | undefined, b: TimeSeriesDescriptor | PlainMessage<TimeSeriesDescriptor> | undefined): boolean {
    return proto3.util.equals(TimeSeriesDescriptor, a, b);
  }
}

/**
 * A descriptor for the value columns in a data point.
 *
 * @generated from message google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor
 */
export class TimeSeriesDescriptor_ValueDescriptor extends Message<TimeSeriesDescriptor_ValueDescriptor> {
  /**
   * The value key.
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * The value type.
   *
   * @generated from field: google.api.MetricDescriptor.ValueType value_type = 2;
   */
  valueType = MetricDescriptor_ValueType.VALUE_TYPE_UNSPECIFIED;

  /**
   * The value stream kind.
   *
   * @generated from field: google.api.MetricDescriptor.MetricKind metric_kind = 3;
   */
  metricKind = MetricDescriptor_MetricKind.METRIC_KIND_UNSPECIFIED;

  /**
   * The unit in which `time_series` point values are reported. `unit`
   * follows the UCUM format for units as seen in
   * https://unitsofmeasure.org/ucum.html.
   * `unit` is only valid if `value_type` is INTEGER, DOUBLE, DISTRIBUTION.
   *
   * @generated from field: string unit = 4;
   */
  unit = "";

  constructor(data?: PartialMessage<TimeSeriesDescriptor_ValueDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value_type", kind: "enum", T: proto3.getEnumType(MetricDescriptor_ValueType) },
    { no: 3, name: "metric_kind", kind: "enum", T: proto3.getEnumType(MetricDescriptor_MetricKind) },
    { no: 4, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesDescriptor_ValueDescriptor {
    return new TimeSeriesDescriptor_ValueDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesDescriptor_ValueDescriptor {
    return new TimeSeriesDescriptor_ValueDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesDescriptor_ValueDescriptor {
    return new TimeSeriesDescriptor_ValueDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeriesDescriptor_ValueDescriptor | PlainMessage<TimeSeriesDescriptor_ValueDescriptor> | undefined, b: TimeSeriesDescriptor_ValueDescriptor | PlainMessage<TimeSeriesDescriptor_ValueDescriptor> | undefined): boolean {
    return proto3.util.equals(TimeSeriesDescriptor_ValueDescriptor, a, b);
  }
}

/**
 * Represents the values of a time series associated with a
 * TimeSeriesDescriptor.
 *
 * @generated from message google.monitoring.v3.TimeSeriesData
 */
export class TimeSeriesData extends Message<TimeSeriesData> {
  /**
   * The values of the labels in the time series identifier, given in the same
   * order as the `label_descriptors` field of the TimeSeriesDescriptor
   * associated with this object. Each value must have a value of the type
   * given in the corresponding entry of `label_descriptors`.
   *
   * @generated from field: repeated google.monitoring.v3.LabelValue label_values = 1;
   */
  labelValues: LabelValue[] = [];

  /**
   * The points in the time series.
   *
   * @generated from field: repeated google.monitoring.v3.TimeSeriesData.PointData point_data = 2;
   */
  pointData: TimeSeriesData_PointData[] = [];

  constructor(data?: PartialMessage<TimeSeriesData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeSeriesData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label_values", kind: "message", T: LabelValue, repeated: true },
    { no: 2, name: "point_data", kind: "message", T: TimeSeriesData_PointData, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesData {
    return new TimeSeriesData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesData {
    return new TimeSeriesData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesData {
    return new TimeSeriesData().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeriesData | PlainMessage<TimeSeriesData> | undefined, b: TimeSeriesData | PlainMessage<TimeSeriesData> | undefined): boolean {
    return proto3.util.equals(TimeSeriesData, a, b);
  }
}

/**
 * A point's value columns and time interval. Each point has one or more
 * point values corresponding to the entries in `point_descriptors` field in
 * the TimeSeriesDescriptor associated with this object.
 *
 * @generated from message google.monitoring.v3.TimeSeriesData.PointData
 */
export class TimeSeriesData_PointData extends Message<TimeSeriesData_PointData> {
  /**
   * The values that make up the point.
   *
   * @generated from field: repeated google.monitoring.v3.TypedValue values = 1;
   */
  values: TypedValue[] = [];

  /**
   * The time interval associated with the point.
   *
   * @generated from field: google.monitoring.v3.TimeInterval time_interval = 2;
   */
  timeInterval?: TimeInterval;

  constructor(data?: PartialMessage<TimeSeriesData_PointData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeSeriesData.PointData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: TypedValue, repeated: true },
    { no: 2, name: "time_interval", kind: "message", T: TimeInterval },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesData_PointData {
    return new TimeSeriesData_PointData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesData_PointData {
    return new TimeSeriesData_PointData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesData_PointData {
    return new TimeSeriesData_PointData().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeriesData_PointData | PlainMessage<TimeSeriesData_PointData> | undefined, b: TimeSeriesData_PointData | PlainMessage<TimeSeriesData_PointData> | undefined): boolean {
    return proto3.util.equals(TimeSeriesData_PointData, a, b);
  }
}

/**
 * A label value.
 *
 * @generated from message google.monitoring.v3.LabelValue
 */
export class LabelValue extends Message<LabelValue> {
  /**
   * The label value can be a bool, int64, or string.
   *
   * @generated from oneof google.monitoring.v3.LabelValue.value
   */
  value: {
    /**
     * A bool label value.
     *
     * @generated from field: bool bool_value = 1;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * An int64 label value.
     *
     * @generated from field: int64 int64_value = 2;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * A string label value.
     *
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LabelValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.LabelValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bool_value", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
    { no: 2, name: "int64_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "value" },
    { no: 3, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelValue {
    return new LabelValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelValue {
    return new LabelValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelValue {
    return new LabelValue().fromJsonString(jsonString, options);
  }

  static equals(a: LabelValue | PlainMessage<LabelValue> | undefined, b: LabelValue | PlainMessage<LabelValue> | undefined): boolean {
    return proto3.util.equals(LabelValue, a, b);
  }
}

/**
 * An error associated with a query in the time series query language format.
 *
 * @generated from message google.monitoring.v3.QueryError
 */
export class QueryError extends Message<QueryError> {
  /**
   * The location of the time series query language text that this error applies
   * to.
   *
   * @generated from field: google.monitoring.v3.TextLocator locator = 1;
   */
  locator?: TextLocator;

  /**
   * The error message.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<QueryError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.QueryError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locator", kind: "message", T: TextLocator },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryError {
    return new QueryError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryError {
    return new QueryError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryError {
    return new QueryError().fromJsonString(jsonString, options);
  }

  static equals(a: QueryError | PlainMessage<QueryError> | undefined, b: QueryError | PlainMessage<QueryError> | undefined): boolean {
    return proto3.util.equals(QueryError, a, b);
  }
}

/**
 * A locator for text. Indicates a particular part of the text of a request or
 * of an object referenced in the request.
 *
 * For example, suppose the request field `text` contains:
 *
 *   text: "The quick brown fox jumps over the lazy dog."
 *
 * Then the locator:
 *
 *   source: "text"
 *   start_position {
 *     line: 1
 *     column: 17
 *   }
 *   end_position {
 *     line: 1
 *     column: 19
 *   }
 *
 * refers to the part of the text: "fox".
 *
 * @generated from message google.monitoring.v3.TextLocator
 */
export class TextLocator extends Message<TextLocator> {
  /**
   * The source of the text. The source may be a field in the request, in which
   * case its format is the format of the
   * google.rpc.BadRequest.FieldViolation.field field in
   * https://cloud.google.com/apis/design/errors#error_details. It may also be
   * be a source other than the request field (e.g. a macro definition
   * referenced in the text of the query), in which case this is the name of
   * the source (e.g. the macro name).
   *
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * The position of the first byte within the text.
   *
   * @generated from field: google.monitoring.v3.TextLocator.Position start_position = 2;
   */
  startPosition?: TextLocator_Position;

  /**
   * The position of the last byte within the text.
   *
   * @generated from field: google.monitoring.v3.TextLocator.Position end_position = 3;
   */
  endPosition?: TextLocator_Position;

  /**
   * If `source`, `start_position`, and `end_position` describe a call on
   * some object (e.g. a macro in the time series query language text) and a
   * location is to be designated in that object's text, `nested_locator`
   * identifies the location within that object.
   *
   * @generated from field: google.monitoring.v3.TextLocator nested_locator = 4;
   */
  nestedLocator?: TextLocator;

  /**
   * When `nested_locator` is set, this field gives the reason for the nesting.
   * Usually, the reason is a macro invocation. In that case, the macro name
   * (including the leading '@') signals the location of the macro call
   * in the text and a macro argument name (including the leading '$') signals
   * the location of the macro argument inside the macro body that got
   * substituted away.
   *
   * @generated from field: string nesting_reason = 5;
   */
  nestingReason = "";

  constructor(data?: PartialMessage<TextLocator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TextLocator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_position", kind: "message", T: TextLocator_Position },
    { no: 3, name: "end_position", kind: "message", T: TextLocator_Position },
    { no: 4, name: "nested_locator", kind: "message", T: TextLocator },
    { no: 5, name: "nesting_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextLocator {
    return new TextLocator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextLocator {
    return new TextLocator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextLocator {
    return new TextLocator().fromJsonString(jsonString, options);
  }

  static equals(a: TextLocator | PlainMessage<TextLocator> | undefined, b: TextLocator | PlainMessage<TextLocator> | undefined): boolean {
    return proto3.util.equals(TextLocator, a, b);
  }
}

/**
 * The position of a byte within the text.
 *
 * @generated from message google.monitoring.v3.TextLocator.Position
 */
export class TextLocator_Position extends Message<TextLocator_Position> {
  /**
   * The line, starting with 1, where the byte is positioned.
   *
   * @generated from field: int32 line = 1;
   */
  line = 0;

  /**
   * The column within the line, starting with 1, where the byte is
   * positioned. This is a byte index even though the text is UTF-8.
   *
   * @generated from field: int32 column = 2;
   */
  column = 0;

  constructor(data?: PartialMessage<TextLocator_Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TextLocator.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextLocator_Position {
    return new TextLocator_Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextLocator_Position {
    return new TextLocator_Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextLocator_Position {
    return new TextLocator_Position().fromJsonString(jsonString, options);
  }

  static equals(a: TextLocator_Position | PlainMessage<TextLocator_Position> | undefined, b: TextLocator_Position | PlainMessage<TextLocator_Position> | undefined): boolean {
    return proto3.util.equals(TextLocator_Position, a, b);
  }
}

