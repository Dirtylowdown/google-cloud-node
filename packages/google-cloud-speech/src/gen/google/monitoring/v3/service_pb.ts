// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/service.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";
import { CalendarPeriod } from "../../type/calendar_period_pb.js";

/**
 * A `Service` is a discrete, autonomous, and network-accessible unit, designed
 * to solve an individual concern
 * ([Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)). In
 * Cloud Monitoring, a `Service` acts as the root resource under which
 * operational aspects of the service are accessible.
 *
 * @generated from message google.monitoring.v3.Service
 */
export class Service extends Message<Service> {
  /**
   * Resource name for this Service. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Name used for UI elements listing this Service.
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * REQUIRED. Service-identifying atoms specifying the underlying service.
   *
   * @generated from oneof google.monitoring.v3.Service.identifier
   */
  identifier: {
    /**
     * Custom service type.
     *
     * @generated from field: google.monitoring.v3.Service.Custom custom = 6;
     */
    value: Service_Custom;
    case: "custom";
  } | {
    /**
     * Type used for App Engine services.
     *
     * @generated from field: google.monitoring.v3.Service.AppEngine app_engine = 7;
     */
    value: Service_AppEngine;
    case: "appEngine";
  } | {
    /**
     * Type used for Cloud Endpoints services.
     *
     * @generated from field: google.monitoring.v3.Service.CloudEndpoints cloud_endpoints = 8;
     */
    value: Service_CloudEndpoints;
    case: "cloudEndpoints";
  } | {
    /**
     * Type used for Istio services that live in a Kubernetes cluster.
     *
     * @generated from field: google.monitoring.v3.Service.ClusterIstio cluster_istio = 9;
     */
    value: Service_ClusterIstio;
    case: "clusterIstio";
  } | {
    /**
     * Type used for Istio services scoped to an Istio mesh.
     *
     * @generated from field: google.monitoring.v3.Service.MeshIstio mesh_istio = 10;
     */
    value: Service_MeshIstio;
    case: "meshIstio";
  } | {
    /**
     * Type used for canonical services scoped to an Istio mesh.
     * Metrics for Istio are
     * [documented here](https://istio.io/latest/docs/reference/config/metrics/)
     *
     * @generated from field: google.monitoring.v3.Service.IstioCanonicalService istio_canonical_service = 11;
     */
    value: Service_IstioCanonicalService;
    case: "istioCanonicalService";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Configuration for how to query telemetry on a Service.
   *
   * @generated from field: google.monitoring.v3.Service.Telemetry telemetry = 13;
   */
  telemetry?: Service_Telemetry;

  /**
   * Labels which have been used to annotate the service. Label keys must start
   * with a letter. Label keys and values may contain lowercase letters,
   * numbers, underscores, and dashes. Label keys and values have a maximum
   * length of 63 characters, and must be less than 128 bytes in size. Up to 64
   * label entries may be stored. For labels which do not have a semantic value,
   * the empty string may be supplied for the label value.
   *
   * @generated from field: map<string, string> user_labels = 14;
   */
  userLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Service>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "custom", kind: "message", T: Service_Custom, oneof: "identifier" },
    { no: 7, name: "app_engine", kind: "message", T: Service_AppEngine, oneof: "identifier" },
    { no: 8, name: "cloud_endpoints", kind: "message", T: Service_CloudEndpoints, oneof: "identifier" },
    { no: 9, name: "cluster_istio", kind: "message", T: Service_ClusterIstio, oneof: "identifier" },
    { no: 10, name: "mesh_istio", kind: "message", T: Service_MeshIstio, oneof: "identifier" },
    { no: 11, name: "istio_canonical_service", kind: "message", T: Service_IstioCanonicalService, oneof: "identifier" },
    { no: 13, name: "telemetry", kind: "message", T: Service_Telemetry },
    { no: 14, name: "user_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service {
    return new Service().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service {
    return new Service().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service {
    return new Service().fromJsonString(jsonString, options);
  }

  static equals(a: Service | PlainMessage<Service> | undefined, b: Service | PlainMessage<Service> | undefined): boolean {
    return proto3.util.equals(Service, a, b);
  }
}

/**
 * Custom view of service telemetry. Currently a place-holder pending final
 * design.
 *
 * @generated from message google.monitoring.v3.Service.Custom
 */
export class Service_Custom extends Message<Service_Custom> {
  constructor(data?: PartialMessage<Service_Custom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.Custom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_Custom {
    return new Service_Custom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_Custom {
    return new Service_Custom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_Custom {
    return new Service_Custom().fromJsonString(jsonString, options);
  }

  static equals(a: Service_Custom | PlainMessage<Service_Custom> | undefined, b: Service_Custom | PlainMessage<Service_Custom> | undefined): boolean {
    return proto3.util.equals(Service_Custom, a, b);
  }
}

/**
 * App Engine service. Learn more at https://cloud.google.com/appengine.
 *
 * @generated from message google.monitoring.v3.Service.AppEngine
 */
export class Service_AppEngine extends Message<Service_AppEngine> {
  /**
   * The ID of the App Engine module underlying this service. Corresponds to
   * the `module_id` resource label in the `gae_app` monitored resource:
   * https://cloud.google.com/monitoring/api/resources#tag_gae_app
   *
   * @generated from field: string module_id = 1;
   */
  moduleId = "";

  constructor(data?: PartialMessage<Service_AppEngine>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.AppEngine";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_AppEngine {
    return new Service_AppEngine().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_AppEngine {
    return new Service_AppEngine().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_AppEngine {
    return new Service_AppEngine().fromJsonString(jsonString, options);
  }

  static equals(a: Service_AppEngine | PlainMessage<Service_AppEngine> | undefined, b: Service_AppEngine | PlainMessage<Service_AppEngine> | undefined): boolean {
    return proto3.util.equals(Service_AppEngine, a, b);
  }
}

/**
 * Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
 *
 * @generated from message google.monitoring.v3.Service.CloudEndpoints
 */
export class Service_CloudEndpoints extends Message<Service_CloudEndpoints> {
  /**
   * The name of the Cloud Endpoints service underlying this service.
   * Corresponds to the `service` resource label in the `api` monitored
   * resource: https://cloud.google.com/monitoring/api/resources#tag_api
   *
   * @generated from field: string service = 1;
   */
  service = "";

  constructor(data?: PartialMessage<Service_CloudEndpoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.CloudEndpoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_CloudEndpoints {
    return new Service_CloudEndpoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_CloudEndpoints {
    return new Service_CloudEndpoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_CloudEndpoints {
    return new Service_CloudEndpoints().fromJsonString(jsonString, options);
  }

  static equals(a: Service_CloudEndpoints | PlainMessage<Service_CloudEndpoints> | undefined, b: Service_CloudEndpoints | PlainMessage<Service_CloudEndpoints> | undefined): boolean {
    return proto3.util.equals(Service_CloudEndpoints, a, b);
  }
}

/**
 * Istio service scoped to a single Kubernetes cluster. Learn more at
 * https://istio.io. Clusters running OSS Istio will have their services
 * ingested as this type.
 *
 * @generated from message google.monitoring.v3.Service.ClusterIstio
 */
export class Service_ClusterIstio extends Message<Service_ClusterIstio> {
  /**
   * The location of the Kubernetes cluster in which this Istio service is
   * defined. Corresponds to the `location` resource label in `k8s_cluster`
   * resources.
   *
   * @generated from field: string location = 1;
   */
  location = "";

  /**
   * The name of the Kubernetes cluster in which this Istio service is
   * defined. Corresponds to the `cluster_name` resource label in
   * `k8s_cluster` resources.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  /**
   * The namespace of the Istio service underlying this service. Corresponds
   * to the `destination_service_namespace` metric label in Istio metrics.
   *
   * @generated from field: string service_namespace = 3;
   */
  serviceNamespace = "";

  /**
   * The name of the Istio service underlying this service. Corresponds to the
   * `destination_service_name` metric label in Istio metrics.
   *
   * @generated from field: string service_name = 4;
   */
  serviceName = "";

  constructor(data?: PartialMessage<Service_ClusterIstio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.ClusterIstio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "service_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_ClusterIstio {
    return new Service_ClusterIstio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_ClusterIstio {
    return new Service_ClusterIstio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_ClusterIstio {
    return new Service_ClusterIstio().fromJsonString(jsonString, options);
  }

  static equals(a: Service_ClusterIstio | PlainMessage<Service_ClusterIstio> | undefined, b: Service_ClusterIstio | PlainMessage<Service_ClusterIstio> | undefined): boolean {
    return proto3.util.equals(Service_ClusterIstio, a, b);
  }
}

/**
 * Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8
 * will have their services ingested as this type.
 *
 * @generated from message google.monitoring.v3.Service.MeshIstio
 */
export class Service_MeshIstio extends Message<Service_MeshIstio> {
  /**
   * Identifier for the mesh in which this Istio service is defined.
   * Corresponds to the `mesh_uid` metric label in Istio metrics.
   *
   * @generated from field: string mesh_uid = 1;
   */
  meshUid = "";

  /**
   * The namespace of the Istio service underlying this service. Corresponds
   * to the `destination_service_namespace` metric label in Istio metrics.
   *
   * @generated from field: string service_namespace = 3;
   */
  serviceNamespace = "";

  /**
   * The name of the Istio service underlying this service. Corresponds to the
   * `destination_service_name` metric label in Istio metrics.
   *
   * @generated from field: string service_name = 4;
   */
  serviceName = "";

  constructor(data?: PartialMessage<Service_MeshIstio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.MeshIstio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mesh_uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "service_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_MeshIstio {
    return new Service_MeshIstio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_MeshIstio {
    return new Service_MeshIstio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_MeshIstio {
    return new Service_MeshIstio().fromJsonString(jsonString, options);
  }

  static equals(a: Service_MeshIstio | PlainMessage<Service_MeshIstio> | undefined, b: Service_MeshIstio | PlainMessage<Service_MeshIstio> | undefined): boolean {
    return proto3.util.equals(Service_MeshIstio, a, b);
  }
}

/**
 * Canonical service scoped to an Istio mesh. Anthos clusters running ASM >=
 * 1.6.8 will have their services ingested as this type.
 *
 * @generated from message google.monitoring.v3.Service.IstioCanonicalService
 */
export class Service_IstioCanonicalService extends Message<Service_IstioCanonicalService> {
  /**
   * Identifier for the Istio mesh in which this canonical service is defined.
   * Corresponds to the `mesh_uid` metric label in
   * [Istio metrics](https://cloud.google.com/monitoring/api/metrics_istio).
   *
   * @generated from field: string mesh_uid = 1;
   */
  meshUid = "";

  /**
   * The namespace of the canonical service underlying this service.
   * Corresponds to the `destination_canonical_service_namespace` metric
   * label in [Istio
   * metrics](https://cloud.google.com/monitoring/api/metrics_istio).
   *
   * @generated from field: string canonical_service_namespace = 3;
   */
  canonicalServiceNamespace = "";

  /**
   * The name of the canonical service underlying this service.
   * Corresponds to the `destination_canonical_service_name` metric label in
   * label in [Istio
   * metrics](https://cloud.google.com/monitoring/api/metrics_istio).
   *
   * @generated from field: string canonical_service = 4;
   */
  canonicalService = "";

  constructor(data?: PartialMessage<Service_IstioCanonicalService>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.IstioCanonicalService";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mesh_uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "canonical_service_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "canonical_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_IstioCanonicalService {
    return new Service_IstioCanonicalService().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_IstioCanonicalService {
    return new Service_IstioCanonicalService().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_IstioCanonicalService {
    return new Service_IstioCanonicalService().fromJsonString(jsonString, options);
  }

  static equals(a: Service_IstioCanonicalService | PlainMessage<Service_IstioCanonicalService> | undefined, b: Service_IstioCanonicalService | PlainMessage<Service_IstioCanonicalService> | undefined): boolean {
    return proto3.util.equals(Service_IstioCanonicalService, a, b);
  }
}

/**
 * Configuration for how to query telemetry on a Service.
 *
 * @generated from message google.monitoring.v3.Service.Telemetry
 */
export class Service_Telemetry extends Message<Service_Telemetry> {
  /**
   * The full name of the resource that defines this service. Formatted as
   * described in https://cloud.google.com/apis/design/resource_names.
   *
   * @generated from field: string resource_name = 1;
   */
  resourceName = "";

  constructor(data?: PartialMessage<Service_Telemetry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Service.Telemetry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Service_Telemetry {
    return new Service_Telemetry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Service_Telemetry {
    return new Service_Telemetry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Service_Telemetry {
    return new Service_Telemetry().fromJsonString(jsonString, options);
  }

  static equals(a: Service_Telemetry | PlainMessage<Service_Telemetry> | undefined, b: Service_Telemetry | PlainMessage<Service_Telemetry> | undefined): boolean {
    return proto3.util.equals(Service_Telemetry, a, b);
  }
}

/**
 * A Service-Level Objective (SLO) describes a level of desired good service. It
 * consists of a service-level indicator (SLI), a performance goal, and a period
 * over which the objective is to be evaluated against that goal. The SLO can
 * use SLIs defined in a number of different manners. Typical SLOs might include
 * "99% of requests in each rolling week have latency below 200 milliseconds" or
 * "99.5% of requests in each calendar month return successfully."
 *
 * @generated from message google.monitoring.v3.ServiceLevelObjective
 */
export class ServiceLevelObjective extends Message<ServiceLevelObjective> {
  /**
   * Resource name for this `ServiceLevelObjective`. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Name used for UI elements listing this SLO.
   *
   * @generated from field: string display_name = 11;
   */
  displayName = "";

  /**
   * The definition of good service, used to measure and calculate the quality
   * of the `Service`'s performance with respect to a single aspect of service
   * quality.
   *
   * @generated from field: google.monitoring.v3.ServiceLevelIndicator service_level_indicator = 3;
   */
  serviceLevelIndicator?: ServiceLevelIndicator;

  /**
   * The fraction of service that must be good in order for this objective to be
   * met. `0 < goal <= 0.999`.
   *
   * @generated from field: double goal = 4;
   */
  goal = 0;

  /**
   * The time period over which the objective will be evaluated.
   *
   * @generated from oneof google.monitoring.v3.ServiceLevelObjective.period
   */
  period: {
    /**
     * A rolling time period, semantically "in the past `<rolling_period>`".
     * Must be an integer multiple of 1 day no larger than 30 days.
     *
     * @generated from field: google.protobuf.Duration rolling_period = 5;
     */
    value: Duration;
    case: "rollingPeriod";
  } | {
    /**
     * A calendar period, semantically "since the start of the current
     * `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
     * `MONTH` are supported.
     *
     * @generated from field: google.type.CalendarPeriod calendar_period = 6;
     */
    value: CalendarPeriod;
    case: "calendarPeriod";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Labels which have been used to annotate the service-level objective. Label
   * keys must start with a letter. Label keys and values may contain lowercase
   * letters, numbers, underscores, and dashes. Label keys and values have a
   * maximum length of 63 characters, and must be less than 128 bytes in size.
   * Up to 64 label entries may be stored. For labels which do not have a
   * semantic value, the empty string may be supplied for the label value.
   *
   * @generated from field: map<string, string> user_labels = 12;
   */
  userLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ServiceLevelObjective>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.ServiceLevelObjective";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "service_level_indicator", kind: "message", T: ServiceLevelIndicator },
    { no: 4, name: "goal", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "rolling_period", kind: "message", T: Duration, oneof: "period" },
    { no: 6, name: "calendar_period", kind: "enum", T: proto3.getEnumType(CalendarPeriod), oneof: "period" },
    { no: 12, name: "user_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceLevelObjective {
    return new ServiceLevelObjective().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceLevelObjective {
    return new ServiceLevelObjective().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceLevelObjective {
    return new ServiceLevelObjective().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceLevelObjective | PlainMessage<ServiceLevelObjective> | undefined, b: ServiceLevelObjective | PlainMessage<ServiceLevelObjective> | undefined): boolean {
    return proto3.util.equals(ServiceLevelObjective, a, b);
  }
}

/**
 * `ServiceLevelObjective.View` determines what form of
 * `ServiceLevelObjective` is returned from `GetServiceLevelObjective`,
 * `ListServiceLevelObjectives`, and `ListServiceLevelObjectiveVersions` RPCs.
 *
 * @generated from enum google.monitoring.v3.ServiceLevelObjective.View
 */
export enum ServiceLevelObjective_View {
  /**
   * Same as FULL.
   *
   * @generated from enum value: VIEW_UNSPECIFIED = 0;
   */
  VIEW_UNSPECIFIED = 0,

  /**
   * Return the embedded `ServiceLevelIndicator` in the form in which it was
   * defined. If it was defined using a `BasicSli`, return that `BasicSli`.
   *
   * @generated from enum value: FULL = 2;
   */
  FULL = 2,

  /**
   * For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
   * return the `ServiceLevelIndicator` with its mode of computation fully
   * spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
   * `RequestBasedSli` or `WindowsBasedSli`, return the
   * `ServiceLevelIndicator` as it was provided.
   *
   * @generated from enum value: EXPLICIT = 1;
   */
  EXPLICIT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ServiceLevelObjective_View)
proto3.util.setEnumType(ServiceLevelObjective_View, "google.monitoring.v3.ServiceLevelObjective.View", [
  { no: 0, name: "VIEW_UNSPECIFIED" },
  { no: 2, name: "FULL" },
  { no: 1, name: "EXPLICIT" },
]);

/**
 * A Service-Level Indicator (SLI) describes the "performance" of a service. For
 * some services, the SLI is well-defined. In such cases, the SLI can be
 * described easily by referencing the well-known SLI and providing the needed
 * parameters. Alternatively, a "custom" SLI can be defined with a query to the
 * underlying metric store. An SLI is defined to be `good_service /
 * total_service` over any queried time interval. The value of performance
 * always falls into the range `0 <= performance <= 1`. A custom SLI describes
 * how to compute this ratio, whether this is by dividing values from a pair of
 * time series, cutting a `Distribution` into good and bad counts, or counting
 * time windows in which the service complies with a criterion. For separation
 * of concerns, a single Service-Level Indicator measures performance for only
 * one aspect of service quality, such as fraction of successful queries or
 * fast-enough queries.
 *
 * @generated from message google.monitoring.v3.ServiceLevelIndicator
 */
export class ServiceLevelIndicator extends Message<ServiceLevelIndicator> {
  /**
   * Service level indicators can be grouped by whether the "unit" of service
   * being measured is based on counts of good requests or on counts of good
   * time windows
   *
   * @generated from oneof google.monitoring.v3.ServiceLevelIndicator.type
   */
  type: {
    /**
     * Basic SLI on a well-known service type.
     *
     * @generated from field: google.monitoring.v3.BasicSli basic_sli = 4;
     */
    value: BasicSli;
    case: "basicSli";
  } | {
    /**
     * Request-based SLIs
     *
     * @generated from field: google.monitoring.v3.RequestBasedSli request_based = 1;
     */
    value: RequestBasedSli;
    case: "requestBased";
  } | {
    /**
     * Windows-based SLIs
     *
     * @generated from field: google.monitoring.v3.WindowsBasedSli windows_based = 2;
     */
    value: WindowsBasedSli;
    case: "windowsBased";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServiceLevelIndicator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.ServiceLevelIndicator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "basic_sli", kind: "message", T: BasicSli, oneof: "type" },
    { no: 1, name: "request_based", kind: "message", T: RequestBasedSli, oneof: "type" },
    { no: 2, name: "windows_based", kind: "message", T: WindowsBasedSli, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceLevelIndicator {
    return new ServiceLevelIndicator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceLevelIndicator {
    return new ServiceLevelIndicator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceLevelIndicator {
    return new ServiceLevelIndicator().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceLevelIndicator | PlainMessage<ServiceLevelIndicator> | undefined, b: ServiceLevelIndicator | PlainMessage<ServiceLevelIndicator> | undefined): boolean {
    return proto3.util.equals(ServiceLevelIndicator, a, b);
  }
}

/**
 * An SLI measuring performance on a well-known service type. Performance will
 * be computed on the basis of pre-defined metrics. The type of the
 * `service_resource` determines the metrics to use and the
 * `service_resource.labels` and `metric_labels` are used to construct a
 * monitoring filter to filter that metric down to just the data relevant to
 * this service.
 *
 * @generated from message google.monitoring.v3.BasicSli
 */
export class BasicSli extends Message<BasicSli> {
  /**
   * OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
   * other methods will not be used to calculate performance for this SLI. If
   * omitted, this SLI applies to all the Service's methods. For service types
   * that don't support breaking down by method, setting this field will result
   * in an error.
   *
   * @generated from field: repeated string method = 7;
   */
  method: string[] = [];

  /**
   * OPTIONAL: The set of locations to which this SLI is relevant. Telemetry
   * from other locations will not be used to calculate performance for this
   * SLI. If omitted, this SLI applies to all locations in which the Service has
   * activity. For service types that don't support breaking down by location,
   * setting this field will result in an error.
   *
   * @generated from field: repeated string location = 8;
   */
  location: string[] = [];

  /**
   * OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
   * from other API versions will not be used to calculate performance for this
   * SLI. If omitted, this SLI applies to all API versions. For service types
   * that don't support breaking down by version, setting this field will result
   * in an error.
   *
   * @generated from field: repeated string version = 9;
   */
  version: string[] = [];

  /**
   * This SLI can be evaluated on the basis of availability or latency.
   *
   * @generated from oneof google.monitoring.v3.BasicSli.sli_criteria
   */
  sliCriteria: {
    /**
     * Good service is defined to be the count of requests made to this service
     * that return successfully.
     *
     * @generated from field: google.monitoring.v3.BasicSli.AvailabilityCriteria availability = 2;
     */
    value: BasicSli_AvailabilityCriteria;
    case: "availability";
  } | {
    /**
     * Good service is defined to be the count of requests made to this service
     * that are fast enough with respect to `latency.threshold`.
     *
     * @generated from field: google.monitoring.v3.BasicSli.LatencyCriteria latency = 3;
     */
    value: BasicSli_LatencyCriteria;
    case: "latency";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BasicSli>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.BasicSli";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "availability", kind: "message", T: BasicSli_AvailabilityCriteria, oneof: "sli_criteria" },
    { no: 3, name: "latency", kind: "message", T: BasicSli_LatencyCriteria, oneof: "sli_criteria" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicSli {
    return new BasicSli().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicSli {
    return new BasicSli().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicSli {
    return new BasicSli().fromJsonString(jsonString, options);
  }

  static equals(a: BasicSli | PlainMessage<BasicSli> | undefined, b: BasicSli | PlainMessage<BasicSli> | undefined): boolean {
    return proto3.util.equals(BasicSli, a, b);
  }
}

/**
 * Future parameters for the availability SLI.
 *
 * @generated from message google.monitoring.v3.BasicSli.AvailabilityCriteria
 */
export class BasicSli_AvailabilityCriteria extends Message<BasicSli_AvailabilityCriteria> {
  constructor(data?: PartialMessage<BasicSli_AvailabilityCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.BasicSli.AvailabilityCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicSli_AvailabilityCriteria {
    return new BasicSli_AvailabilityCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicSli_AvailabilityCriteria {
    return new BasicSli_AvailabilityCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicSli_AvailabilityCriteria {
    return new BasicSli_AvailabilityCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: BasicSli_AvailabilityCriteria | PlainMessage<BasicSli_AvailabilityCriteria> | undefined, b: BasicSli_AvailabilityCriteria | PlainMessage<BasicSli_AvailabilityCriteria> | undefined): boolean {
    return proto3.util.equals(BasicSli_AvailabilityCriteria, a, b);
  }
}

/**
 * Parameters for a latency threshold SLI.
 *
 * @generated from message google.monitoring.v3.BasicSli.LatencyCriteria
 */
export class BasicSli_LatencyCriteria extends Message<BasicSli_LatencyCriteria> {
  /**
   * Good service is defined to be the count of requests made to this service
   * that return in no more than `threshold`.
   *
   * @generated from field: google.protobuf.Duration threshold = 3;
   */
  threshold?: Duration;

  constructor(data?: PartialMessage<BasicSli_LatencyCriteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.BasicSli.LatencyCriteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "threshold", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicSli_LatencyCriteria {
    return new BasicSli_LatencyCriteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicSli_LatencyCriteria {
    return new BasicSli_LatencyCriteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicSli_LatencyCriteria {
    return new BasicSli_LatencyCriteria().fromJsonString(jsonString, options);
  }

  static equals(a: BasicSli_LatencyCriteria | PlainMessage<BasicSli_LatencyCriteria> | undefined, b: BasicSli_LatencyCriteria | PlainMessage<BasicSli_LatencyCriteria> | undefined): boolean {
    return proto3.util.equals(BasicSli_LatencyCriteria, a, b);
  }
}

/**
 * Range of numerical values within `min` and `max`.
 *
 * @generated from message google.monitoring.v3.Range
 */
export class Range extends Message<Range> {
  /**
   * Range minimum.
   *
   * @generated from field: double min = 1;
   */
  min = 0;

  /**
   * Range maximum.
   *
   * @generated from field: double max = 2;
   */
  max = 0;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * Service Level Indicators for which atomic units of service are counted
 * directly.
 *
 * @generated from message google.monitoring.v3.RequestBasedSli
 */
export class RequestBasedSli extends Message<RequestBasedSli> {
  /**
   * The means to compute a ratio of `good_service` to `total_service`.
   *
   * @generated from oneof google.monitoring.v3.RequestBasedSli.method
   */
  method: {
    /**
     * `good_total_ratio` is used when the ratio of `good_service` to
     * `total_service` is computed from two `TimeSeries`.
     *
     * @generated from field: google.monitoring.v3.TimeSeriesRatio good_total_ratio = 1;
     */
    value: TimeSeriesRatio;
    case: "goodTotalRatio";
  } | {
    /**
     * `distribution_cut` is used when `good_service` is a count of values
     * aggregated in a `Distribution` that fall into a good range. The
     * `total_service` is the total count of all values aggregated in the
     * `Distribution`.
     *
     * @generated from field: google.monitoring.v3.DistributionCut distribution_cut = 3;
     */
    value: DistributionCut;
    case: "distributionCut";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RequestBasedSli>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.RequestBasedSli";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "good_total_ratio", kind: "message", T: TimeSeriesRatio, oneof: "method" },
    { no: 3, name: "distribution_cut", kind: "message", T: DistributionCut, oneof: "method" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestBasedSli {
    return new RequestBasedSli().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestBasedSli {
    return new RequestBasedSli().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestBasedSli {
    return new RequestBasedSli().fromJsonString(jsonString, options);
  }

  static equals(a: RequestBasedSli | PlainMessage<RequestBasedSli> | undefined, b: RequestBasedSli | PlainMessage<RequestBasedSli> | undefined): boolean {
    return proto3.util.equals(RequestBasedSli, a, b);
  }
}

/**
 * A `TimeSeriesRatio` specifies two `TimeSeries` to use for computing the
 * `good_service / total_service` ratio. The specified `TimeSeries` must have
 * `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
 * DELTA` or `MetricKind = CUMULATIVE`. The `TimeSeriesRatio` must specify
 * exactly two of good, bad, and total, and the relationship `good_service +
 * bad_service = total_service` will be assumed.
 *
 * @generated from message google.monitoring.v3.TimeSeriesRatio
 */
export class TimeSeriesRatio extends Message<TimeSeriesRatio> {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` quantifying good service provided. Must have
   * `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
   * DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @generated from field: string good_service_filter = 4;
   */
  goodServiceFilter = "";

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` quantifying bad service, either demanded service
   * that was not provided or demanded service that was of inadequate quality.
   * Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have
   * `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @generated from field: string bad_service_filter = 5;
   */
  badServiceFilter = "";

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` quantifying total demanded service. Must have
   * `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
   * DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @generated from field: string total_service_filter = 6;
   */
  totalServiceFilter = "";

  constructor(data?: PartialMessage<TimeSeriesRatio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeSeriesRatio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "good_service_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "bad_service_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "total_service_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesRatio {
    return new TimeSeriesRatio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesRatio {
    return new TimeSeriesRatio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesRatio {
    return new TimeSeriesRatio().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeriesRatio | PlainMessage<TimeSeriesRatio> | undefined, b: TimeSeriesRatio | PlainMessage<TimeSeriesRatio> | undefined): boolean {
    return proto3.util.equals(TimeSeriesRatio, a, b);
  }
}

/**
 * A `DistributionCut` defines a `TimeSeries` and thresholds used for measuring
 * good service and total service. The `TimeSeries` must have `ValueType =
 * DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`. The
 * computed `good_service` will be the estimated count of values in the
 * `Distribution` that fall within the specified `min` and `max`.
 *
 * @generated from message google.monitoring.v3.DistributionCut
 */
export class DistributionCut extends Message<DistributionCut> {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` aggregating values. Must have `ValueType =
   * DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @generated from field: string distribution_filter = 4;
   */
  distributionFilter = "";

  /**
   * Range of values considered "good." For a one-sided range, set one bound to
   * an infinite value.
   *
   * @generated from field: google.monitoring.v3.Range range = 5;
   */
  range?: Range;

  constructor(data?: PartialMessage<DistributionCut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.DistributionCut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "distribution_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "range", kind: "message", T: Range },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DistributionCut {
    return new DistributionCut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DistributionCut {
    return new DistributionCut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DistributionCut {
    return new DistributionCut().fromJsonString(jsonString, options);
  }

  static equals(a: DistributionCut | PlainMessage<DistributionCut> | undefined, b: DistributionCut | PlainMessage<DistributionCut> | undefined): boolean {
    return proto3.util.equals(DistributionCut, a, b);
  }
}

/**
 * A `WindowsBasedSli` defines `good_service` as the count of time windows for
 * which the provided service was of good quality. Criteria for determining
 * if service was good are embedded in the `window_criterion`.
 *
 * @generated from message google.monitoring.v3.WindowsBasedSli
 */
export class WindowsBasedSli extends Message<WindowsBasedSli> {
  /**
   * The criterion to use for evaluating window goodness.
   *
   * @generated from oneof google.monitoring.v3.WindowsBasedSli.window_criterion
   */
  windowCriterion: {
    /**
     * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
     * specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
     * any `true` values appear in the window.
     *
     * @generated from field: string good_bad_metric_filter = 5;
     */
    value: string;
    case: "goodBadMetricFilter";
  } | {
    /**
     * A window is good if its `performance` is high enough.
     *
     * @generated from field: google.monitoring.v3.WindowsBasedSli.PerformanceThreshold good_total_ratio_threshold = 2;
     */
    value: WindowsBasedSli_PerformanceThreshold;
    case: "goodTotalRatioThreshold";
  } | {
    /**
     * A window is good if the metric's value is in a good range, averaged
     * across returned streams.
     *
     * @generated from field: google.monitoring.v3.WindowsBasedSli.MetricRange metric_mean_in_range = 6;
     */
    value: WindowsBasedSli_MetricRange;
    case: "metricMeanInRange";
  } | {
    /**
     * A window is good if the metric's value is in a good range, summed across
     * returned streams.
     *
     * @generated from field: google.monitoring.v3.WindowsBasedSli.MetricRange metric_sum_in_range = 7;
     */
    value: WindowsBasedSli_MetricRange;
    case: "metricSumInRange";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Duration over which window quality is evaluated. Must be an integer
   * fraction of a day and at least `60s`.
   *
   * @generated from field: google.protobuf.Duration window_period = 4;
   */
  windowPeriod?: Duration;

  constructor(data?: PartialMessage<WindowsBasedSli>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.WindowsBasedSli";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "good_bad_metric_filter", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "window_criterion" },
    { no: 2, name: "good_total_ratio_threshold", kind: "message", T: WindowsBasedSli_PerformanceThreshold, oneof: "window_criterion" },
    { no: 6, name: "metric_mean_in_range", kind: "message", T: WindowsBasedSli_MetricRange, oneof: "window_criterion" },
    { no: 7, name: "metric_sum_in_range", kind: "message", T: WindowsBasedSli_MetricRange, oneof: "window_criterion" },
    { no: 4, name: "window_period", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsBasedSli {
    return new WindowsBasedSli().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsBasedSli {
    return new WindowsBasedSli().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsBasedSli {
    return new WindowsBasedSli().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsBasedSli | PlainMessage<WindowsBasedSli> | undefined, b: WindowsBasedSli | PlainMessage<WindowsBasedSli> | undefined): boolean {
    return proto3.util.equals(WindowsBasedSli, a, b);
  }
}

/**
 * A `PerformanceThreshold` is used when each window is good when that window
 * has a sufficiently high `performance`.
 *
 * @generated from message google.monitoring.v3.WindowsBasedSli.PerformanceThreshold
 */
export class WindowsBasedSli_PerformanceThreshold extends Message<WindowsBasedSli_PerformanceThreshold> {
  /**
   * The means, either a request-based SLI or a basic SLI, by which to compute
   * performance over a window.
   *
   * @generated from oneof google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.type
   */
  type: {
    /**
     * `RequestBasedSli` to evaluate to judge window quality.
     *
     * @generated from field: google.monitoring.v3.RequestBasedSli performance = 1;
     */
    value: RequestBasedSli;
    case: "performance";
  } | {
    /**
     * `BasicSli` to evaluate to judge window quality.
     *
     * @generated from field: google.monitoring.v3.BasicSli basic_sli_performance = 3;
     */
    value: BasicSli;
    case: "basicSliPerformance";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * If window `performance >= threshold`, the window is counted as good.
   *
   * @generated from field: double threshold = 2;
   */
  threshold = 0;

  constructor(data?: PartialMessage<WindowsBasedSli_PerformanceThreshold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.WindowsBasedSli.PerformanceThreshold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "performance", kind: "message", T: RequestBasedSli, oneof: "type" },
    { no: 3, name: "basic_sli_performance", kind: "message", T: BasicSli, oneof: "type" },
    { no: 2, name: "threshold", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsBasedSli_PerformanceThreshold {
    return new WindowsBasedSli_PerformanceThreshold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsBasedSli_PerformanceThreshold {
    return new WindowsBasedSli_PerformanceThreshold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsBasedSli_PerformanceThreshold {
    return new WindowsBasedSli_PerformanceThreshold().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsBasedSli_PerformanceThreshold | PlainMessage<WindowsBasedSli_PerformanceThreshold> | undefined, b: WindowsBasedSli_PerformanceThreshold | PlainMessage<WindowsBasedSli_PerformanceThreshold> | undefined): boolean {
    return proto3.util.equals(WindowsBasedSli_PerformanceThreshold, a, b);
  }
}

/**
 * A `MetricRange` is used when each window is good when the value x of a
 * single `TimeSeries` satisfies `range.min <= x <= range.max`. The provided
 * `TimeSeries` must have `ValueType = INT64` or `ValueType = DOUBLE` and
 * `MetricKind = GAUGE`.
 *
 * @generated from message google.monitoring.v3.WindowsBasedSli.MetricRange
 */
export class WindowsBasedSli_MetricRange extends Message<WindowsBasedSli_MetricRange> {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying the `TimeSeries` to use for evaluating window quality.
   *
   * @generated from field: string time_series = 1;
   */
  timeSeries = "";

  /**
   * Range of values considered "good." For a one-sided range, set one bound
   * to an infinite value.
   *
   * @generated from field: google.monitoring.v3.Range range = 4;
   */
  range?: Range;

  constructor(data?: PartialMessage<WindowsBasedSli_MetricRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.WindowsBasedSli.MetricRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time_series", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "range", kind: "message", T: Range },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsBasedSli_MetricRange {
    return new WindowsBasedSli_MetricRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsBasedSli_MetricRange {
    return new WindowsBasedSli_MetricRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsBasedSli_MetricRange {
    return new WindowsBasedSli_MetricRange().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsBasedSli_MetricRange | PlainMessage<WindowsBasedSli_MetricRange> | undefined, b: WindowsBasedSli_MetricRange | PlainMessage<WindowsBasedSli_MetricRange> | undefined): boolean {
    return proto3.util.equals(WindowsBasedSli_MetricRange, a, b);
  }
}

