// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/cloud/speech/v1/resource.proto (package google.cloud.speech.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * A set of words or phrases that represents a common concept likely to appear
 * in your audio, for example a list of passenger ship names. CustomClass items
 * can be substituted into placeholders that you set in PhraseSet phrases.
 *
 * @generated from message google.cloud.speech.v1.CustomClass
 */
export class CustomClass extends Message<CustomClass> {
  /**
   * The resource name of the custom class.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * If this custom class is a resource, the custom_class_id is the resource id
   * of the CustomClass. Case sensitive.
   *
   * @generated from field: string custom_class_id = 2;
   */
  customClassId = "";

  /**
   * A collection of class items.
   *
   * @generated from field: repeated google.cloud.speech.v1.CustomClass.ClassItem items = 3;
   */
  items: CustomClass_ClassItem[] = [];

  constructor(data?: PartialMessage<CustomClass>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1.CustomClass";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "custom_class_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "items", kind: "message", T: CustomClass_ClassItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomClass {
    return new CustomClass().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomClass {
    return new CustomClass().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomClass {
    return new CustomClass().fromJsonString(jsonString, options);
  }

  static equals(a: CustomClass | PlainMessage<CustomClass> | undefined, b: CustomClass | PlainMessage<CustomClass> | undefined): boolean {
    return proto3.util.equals(CustomClass, a, b);
  }
}

/**
 * An item of the class.
 *
 * @generated from message google.cloud.speech.v1.CustomClass.ClassItem
 */
export class CustomClass_ClassItem extends Message<CustomClass_ClassItem> {
  /**
   * The class item's value.
   *
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<CustomClass_ClassItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1.CustomClass.ClassItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomClass_ClassItem {
    return new CustomClass_ClassItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomClass_ClassItem {
    return new CustomClass_ClassItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomClass_ClassItem {
    return new CustomClass_ClassItem().fromJsonString(jsonString, options);
  }

  static equals(a: CustomClass_ClassItem | PlainMessage<CustomClass_ClassItem> | undefined, b: CustomClass_ClassItem | PlainMessage<CustomClass_ClassItem> | undefined): boolean {
    return proto3.util.equals(CustomClass_ClassItem, a, b);
  }
}

/**
 * Provides "hints" to the speech recognizer to favor specific words and phrases
 * in the results.
 *
 * @generated from message google.cloud.speech.v1.PhraseSet
 */
export class PhraseSet extends Message<PhraseSet> {
  /**
   * The resource name of the phrase set.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A list of word and phrases.
   *
   * @generated from field: repeated google.cloud.speech.v1.PhraseSet.Phrase phrases = 2;
   */
  phrases: PhraseSet_Phrase[] = [];

  /**
   * Hint Boost. Positive value will increase the probability that a specific
   * phrase will be recognized over other similar sounding phrases. The higher
   * the boost, the higher the chance of false positive recognition as well.
   * Negative boost values would correspond to anti-biasing. Anti-biasing is not
   * enabled, so negative boost will simply be ignored. Though `boost` can
   * accept a wide range of positive values, most use cases are best served with
   * values between 0 (exclusive) and 20. We recommend using a binary search
   * approach to finding the optimal value for your use case as well as adding
   * phrases both with and without boost to your requests.
   *
   * @generated from field: float boost = 4;
   */
  boost = 0;

  constructor(data?: PartialMessage<PhraseSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1.PhraseSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "phrases", kind: "message", T: PhraseSet_Phrase, repeated: true },
    { no: 4, name: "boost", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhraseSet {
    return new PhraseSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhraseSet {
    return new PhraseSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhraseSet {
    return new PhraseSet().fromJsonString(jsonString, options);
  }

  static equals(a: PhraseSet | PlainMessage<PhraseSet> | undefined, b: PhraseSet | PlainMessage<PhraseSet> | undefined): boolean {
    return proto3.util.equals(PhraseSet, a, b);
  }
}

/**
 * A phrases containing words and phrase "hints" so that
 * the speech recognition is more likely to recognize them. This can be used
 * to improve the accuracy for specific words and phrases, for example, if
 * specific commands are typically spoken by the user. This can also be used
 * to add additional words to the vocabulary of the recognizer. See
 * [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
 *
 * List items can also include pre-built or custom classes containing groups
 * of words that represent common concepts that occur in natural language. For
 * example, rather than providing a phrase hint for every month of the
 * year (e.g. "i was born in january", "i was born in febuary", ...), use the
 * pre-built `$MONTH` class improves the likelihood of correctly transcribing
 * audio that includes months (e.g. "i was born in $month").
 * To refer to pre-built classes, use the class' symbol prepended with `$`
 * e.g. `$MONTH`. To refer to custom classes that were defined inline in the
 * request, set the class's `custom_class_id` to a string unique to all class
 * resources and inline classes. Then use the class' id wrapped in $`{...}`
 * e.g. "${my-months}". To refer to custom classes resources, use the class'
 * id wrapped in `${}` (e.g. `${my-months}`).
 *
 * Speech-to-Text supports three locations: `global`, `us` (US North America),
 * and `eu` (Europe). If you are calling the `speech.googleapis.com`
 * endpoint, use the `global` location. To specify a region, use a
 * [regional endpoint](https://cloud.google.com/speech-to-text/docs/endpoints)
 * with matching `us` or `eu` location value.
 *
 * @generated from message google.cloud.speech.v1.PhraseSet.Phrase
 */
export class PhraseSet_Phrase extends Message<PhraseSet_Phrase> {
  /**
   * The phrase itself.
   *
   * @generated from field: string value = 1;
   */
  value = "";

  /**
   * Hint Boost. Overrides the boost set at the phrase set level.
   * Positive value will increase the probability that a specific phrase will
   * be recognized over other similar sounding phrases. The higher the boost,
   * the higher the chance of false positive recognition as well. Negative
   * boost will simply be ignored. Though `boost` can accept a wide range of
   * positive values, most use cases are best served
   * with values between 0 and 20. We recommend using a binary search approach
   * to finding the optimal value for your use case as well as adding
   * phrases both with and without boost to your requests.
   *
   * @generated from field: float boost = 2;
   */
  boost = 0;

  constructor(data?: PartialMessage<PhraseSet_Phrase>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1.PhraseSet.Phrase";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "boost", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhraseSet_Phrase {
    return new PhraseSet_Phrase().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhraseSet_Phrase {
    return new PhraseSet_Phrase().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhraseSet_Phrase {
    return new PhraseSet_Phrase().fromJsonString(jsonString, options);
  }

  static equals(a: PhraseSet_Phrase | PlainMessage<PhraseSet_Phrase> | undefined, b: PhraseSet_Phrase | PlainMessage<PhraseSet_Phrase> | undefined): boolean {
    return proto3.util.equals(PhraseSet_Phrase, a, b);
  }
}

/**
 * Speech adaptation configuration.
 *
 * @generated from message google.cloud.speech.v1.SpeechAdaptation
 */
export class SpeechAdaptation extends Message<SpeechAdaptation> {
  /**
   * A collection of phrase sets. To specify the hints inline, leave the
   * phrase set's `name` blank and fill in the rest of its fields. Any
   * phrase set can use any custom class.
   *
   * @generated from field: repeated google.cloud.speech.v1.PhraseSet phrase_sets = 1;
   */
  phraseSets: PhraseSet[] = [];

  /**
   * A collection of phrase set resource names to use.
   *
   * @generated from field: repeated string phrase_set_references = 2;
   */
  phraseSetReferences: string[] = [];

  /**
   * A collection of custom classes. To specify the classes inline, leave the
   * class' `name` blank and fill in the rest of its fields, giving it a unique
   * `custom_class_id`. Refer to the inline defined class in phrase hints by its
   * `custom_class_id`.
   *
   * @generated from field: repeated google.cloud.speech.v1.CustomClass custom_classes = 3;
   */
  customClasses: CustomClass[] = [];

  /**
   * Augmented Backus-Naur form (ABNF) is a standardized grammar notation
   * comprised by a set of derivation rules.
   * See specifications: https://www.w3.org/TR/speech-grammar
   *
   * @generated from field: google.cloud.speech.v1.SpeechAdaptation.ABNFGrammar abnf_grammar = 4;
   */
  abnfGrammar?: SpeechAdaptation_ABNFGrammar;

  constructor(data?: PartialMessage<SpeechAdaptation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1.SpeechAdaptation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phrase_sets", kind: "message", T: PhraseSet, repeated: true },
    { no: 2, name: "phrase_set_references", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "custom_classes", kind: "message", T: CustomClass, repeated: true },
    { no: 4, name: "abnf_grammar", kind: "message", T: SpeechAdaptation_ABNFGrammar },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeechAdaptation {
    return new SpeechAdaptation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeechAdaptation {
    return new SpeechAdaptation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeechAdaptation {
    return new SpeechAdaptation().fromJsonString(jsonString, options);
  }

  static equals(a: SpeechAdaptation | PlainMessage<SpeechAdaptation> | undefined, b: SpeechAdaptation | PlainMessage<SpeechAdaptation> | undefined): boolean {
    return proto3.util.equals(SpeechAdaptation, a, b);
  }
}

/**
 * @generated from message google.cloud.speech.v1.SpeechAdaptation.ABNFGrammar
 */
export class SpeechAdaptation_ABNFGrammar extends Message<SpeechAdaptation_ABNFGrammar> {
  /**
   * All declarations and rules of an ABNF grammar broken up into multiple
   * strings that will end up concatenated.
   *
   * @generated from field: repeated string abnf_strings = 1;
   */
  abnfStrings: string[] = [];

  constructor(data?: PartialMessage<SpeechAdaptation_ABNFGrammar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1.SpeechAdaptation.ABNFGrammar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "abnf_strings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeechAdaptation_ABNFGrammar {
    return new SpeechAdaptation_ABNFGrammar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeechAdaptation_ABNFGrammar {
    return new SpeechAdaptation_ABNFGrammar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeechAdaptation_ABNFGrammar {
    return new SpeechAdaptation_ABNFGrammar().fromJsonString(jsonString, options);
  }

  static equals(a: SpeechAdaptation_ABNFGrammar | PlainMessage<SpeechAdaptation_ABNFGrammar> | undefined, b: SpeechAdaptation_ABNFGrammar | PlainMessage<SpeechAdaptation_ABNFGrammar> | undefined): boolean {
    return proto3.util.equals(SpeechAdaptation_ABNFGrammar, a, b);
  }
}

